"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ec2 = require("../lib");
/// !show
// Pick the right Amazon Linux edition. All arguments shown are optional
// and will default to these values when omitted.
const amznLinux = ec2.MachineImage.latestAmazonLinux({
    generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX,
    edition: ec2.AmazonLinuxEdition.STANDARD,
    virtualization: ec2.AmazonLinuxVirt.HVM,
    storage: ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
    cpuType: ec2.AmazonLinuxCpuType.X86_64,
});
// Pick a Windows edition to use
const windows = ec2.MachineImage.latestWindows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE);
// Read AMI id from SSM parameter store
const ssm = ec2.MachineImage.fromSsmParameter('/my/ami', { os: ec2.OperatingSystemType.LINUX });
// Look up the most recent image matching a set of AMI filters.
// In this case, look up the NAT instance AMI, by using a wildcard
// in the 'name' field:
const natAmi = ec2.MachineImage.lookup({
    name: 'amzn-ami-vpc-nat-*',
    owners: ['amazon'],
});
// For other custom (Linux) images, instantiate a `GenericLinuxImage` with
// a map giving the AMI to in for each region:
const linux = ec2.MachineImage.genericLinux({
    'us-east-1': 'ami-97785bed',
    'eu-west-1': 'ami-12345678',
    // ...
});
// For other custom (Windows) images, instantiate a `GenericWindowsImage` with
// a map giving the AMI to in for each region:
const genericWindows = ec2.MachineImage.genericWindows({
    'us-east-1': 'ami-97785bed',
    'eu-west-1': 'ami-12345678',
    // ...
});
/// !hide
Array.isArray(windows);
Array.isArray(amznLinux);
Array.isArray(linux);
Array.isArray(ssm);
Array.isArray(genericWindows);
Array.isArray(natAmi);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhhbXBsZS5pbWFnZXMubGl0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZXhhbXBsZS5pbWFnZXMubGl0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsOEJBQThCO0FBRTlCLFNBQVM7QUFDVCx3RUFBd0U7QUFDeEUsaURBQWlEO0FBQ2pELE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUM7SUFDbkQsVUFBVSxFQUFFLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZO0lBQ2xELE9BQU8sRUFBRSxHQUFHLENBQUMsa0JBQWtCLENBQUMsUUFBUTtJQUN4QyxjQUFjLEVBQUUsR0FBRyxDQUFDLGVBQWUsQ0FBQyxHQUFHO0lBQ3ZDLE9BQU8sRUFBRSxHQUFHLENBQUMsa0JBQWtCLENBQUMsZUFBZTtJQUMvQyxPQUFPLEVBQUUsR0FBRyxDQUFDLGtCQUFrQixDQUFDLE1BQU07Q0FDdkMsQ0FBQyxDQUFDO0FBRUgsZ0NBQWdDO0FBQ2hDLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMscUNBQXFDLENBQUMsQ0FBQztBQUV6Ryx1Q0FBdUM7QUFDdkMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7QUFFaEcsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSx1QkFBdUI7QUFDdkIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDckMsSUFBSSxFQUFFLG9CQUFvQjtJQUMxQixNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUM7Q0FDbkIsQ0FBQyxDQUFDO0FBRUgsMEVBQTBFO0FBQzFFLDhDQUE4QztBQUM5QyxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQztJQUMxQyxXQUFXLEVBQUUsY0FBYztJQUMzQixXQUFXLEVBQUUsY0FBYztJQUMzQixNQUFNO0NBQ1AsQ0FBQyxDQUFDO0FBRUgsOEVBQThFO0FBQzlFLDhDQUE4QztBQUM5QyxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQztJQUNyRCxXQUFXLEVBQUUsY0FBYztJQUMzQixXQUFXLEVBQUUsY0FBYztJQUMzQixNQUFNO0NBQ1AsQ0FBQyxDQUFDO0FBQ0gsU0FBUztBQUVULEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN6QixLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUM5QixLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZWMyIGZyb20gJy4uL2xpYic7XG5cbi8vLyAhc2hvd1xuLy8gUGljayB0aGUgcmlnaHQgQW1hem9uIExpbnV4IGVkaXRpb24uIEFsbCBhcmd1bWVudHMgc2hvd24gYXJlIG9wdGlvbmFsXG4vLyBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZXNlIHZhbHVlcyB3aGVuIG9taXR0ZWQuXG5jb25zdCBhbXpuTGludXggPSBlYzIuTWFjaGluZUltYWdlLmxhdGVzdEFtYXpvbkxpbnV4KHtcbiAgZ2VuZXJhdGlvbjogZWMyLkFtYXpvbkxpbnV4R2VuZXJhdGlvbi5BTUFaT05fTElOVVgsXG4gIGVkaXRpb246IGVjMi5BbWF6b25MaW51eEVkaXRpb24uU1RBTkRBUkQsXG4gIHZpcnR1YWxpemF0aW9uOiBlYzIuQW1hem9uTGludXhWaXJ0LkhWTSxcbiAgc3RvcmFnZTogZWMyLkFtYXpvbkxpbnV4U3RvcmFnZS5HRU5FUkFMX1BVUlBPU0UsXG4gIGNwdVR5cGU6IGVjMi5BbWF6b25MaW51eENwdVR5cGUuWDg2XzY0LFxufSk7XG5cbi8vIFBpY2sgYSBXaW5kb3dzIGVkaXRpb24gdG8gdXNlXG5jb25zdCB3aW5kb3dzID0gZWMyLk1hY2hpbmVJbWFnZS5sYXRlc3RXaW5kb3dzKGVjMi5XaW5kb3dzVmVyc2lvbi5XSU5ET1dTX1NFUlZFUl8yMDE5X0VOR0xJU0hfRlVMTF9CQVNFKTtcblxuLy8gUmVhZCBBTUkgaWQgZnJvbSBTU00gcGFyYW1ldGVyIHN0b3JlXG5jb25zdCBzc20gPSBlYzIuTWFjaGluZUltYWdlLmZyb21Tc21QYXJhbWV0ZXIoJy9teS9hbWknLCB7IG9zOiBlYzIuT3BlcmF0aW5nU3lzdGVtVHlwZS5MSU5VWCB9KTtcblxuLy8gTG9vayB1cCB0aGUgbW9zdCByZWNlbnQgaW1hZ2UgbWF0Y2hpbmcgYSBzZXQgb2YgQU1JIGZpbHRlcnMuXG4vLyBJbiB0aGlzIGNhc2UsIGxvb2sgdXAgdGhlIE5BVCBpbnN0YW5jZSBBTUksIGJ5IHVzaW5nIGEgd2lsZGNhcmRcbi8vIGluIHRoZSAnbmFtZScgZmllbGQ6XG5jb25zdCBuYXRBbWkgPSBlYzIuTWFjaGluZUltYWdlLmxvb2t1cCh7XG4gIG5hbWU6ICdhbXpuLWFtaS12cGMtbmF0LSonLFxuICBvd25lcnM6IFsnYW1hem9uJ10sXG59KTtcblxuLy8gRm9yIG90aGVyIGN1c3RvbSAoTGludXgpIGltYWdlcywgaW5zdGFudGlhdGUgYSBgR2VuZXJpY0xpbnV4SW1hZ2VgIHdpdGhcbi8vIGEgbWFwIGdpdmluZyB0aGUgQU1JIHRvIGluIGZvciBlYWNoIHJlZ2lvbjpcbmNvbnN0IGxpbnV4ID0gZWMyLk1hY2hpbmVJbWFnZS5nZW5lcmljTGludXgoe1xuICAndXMtZWFzdC0xJzogJ2FtaS05Nzc4NWJlZCcsXG4gICdldS13ZXN0LTEnOiAnYW1pLTEyMzQ1Njc4JyxcbiAgLy8gLi4uXG59KTtcblxuLy8gRm9yIG90aGVyIGN1c3RvbSAoV2luZG93cykgaW1hZ2VzLCBpbnN0YW50aWF0ZSBhIGBHZW5lcmljV2luZG93c0ltYWdlYCB3aXRoXG4vLyBhIG1hcCBnaXZpbmcgdGhlIEFNSSB0byBpbiBmb3IgZWFjaCByZWdpb246XG5jb25zdCBnZW5lcmljV2luZG93cyA9IGVjMi5NYWNoaW5lSW1hZ2UuZ2VuZXJpY1dpbmRvd3Moe1xuICAndXMtZWFzdC0xJzogJ2FtaS05Nzc4NWJlZCcsXG4gICdldS13ZXN0LTEnOiAnYW1pLTEyMzQ1Njc4JyxcbiAgLy8gLi4uXG59KTtcbi8vLyAhaGlkZVxuXG5BcnJheS5pc0FycmF5KHdpbmRvd3MpO1xuQXJyYXkuaXNBcnJheShhbXpuTGludXgpO1xuQXJyYXkuaXNBcnJheShsaW51eCk7XG5BcnJheS5pc0FycmF5KHNzbSk7XG5BcnJheS5pc0FycmF5KGdlbmVyaWNXaW5kb3dzKTtcbkFycmF5LmlzQXJyYXkobmF0QW1pKTtcbiJdfQ==