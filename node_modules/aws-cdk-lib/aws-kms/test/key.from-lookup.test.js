"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxschema = require("../../cloud-assembly-schema");
const core_1 = require("../../core");
const lib_1 = require("../lib");
test('requires concrete values', () => {
    expect(() => {
        // GIVEN
        const stack = new core_1.Stack();
        lib_1.Key.fromLookup(stack, 'Key', {
            aliasName: core_1.Lazy.string({ produce: () => 'some-id' }),
        });
    }).toThrow('All arguments to Key.fromLookup() must be concrete (no Tokens)');
});
test('return correct key', () => {
    const previous = mockKeyContextProviderWith({
        keyId: '12345678-1234-1234-1234-123456789012',
    }, options => {
        expect(options.aliasName).toEqual('alias/foo');
    });
    const stack = new core_1.Stack(undefined, undefined, { env: { region: 'us-east-1', account: '123456789012' } });
    const key = lib_1.Key.fromLookup(stack, 'Key', {
        aliasName: 'alias/foo',
    });
    expect(key.keyId).toEqual('12345678-1234-1234-1234-123456789012');
    expect(stack.resolve(key.keyArn)).toEqual({
        'Fn::Join': ['', [
                'arn:',
                { Ref: 'AWS::Partition' },
                ':kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012',
            ]],
    });
    restoreContextProvider(previous);
});
function mockKeyContextProviderWith(response, paramValidator) {
    const previous = core_1.ContextProvider.getValue;
    core_1.ContextProvider.getValue = (_scope, options) => {
        // do some basic sanity checks
        expect(options.provider).toEqual(cxschema.ContextProvider.KEY_PROVIDER);
        if (paramValidator) {
            paramValidator(options.props);
        }
        return {
            value: {
                ...response,
            },
        };
    };
    return previous;
}
function restoreContextProvider(previous) {
    core_1.ContextProvider.getValue = previous;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5LmZyb20tbG9va3VwLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJrZXkuZnJvbS1sb29rdXAudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdEQUF3RDtBQUN4RCxxQ0FBeUc7QUFHekcsZ0NBQTZCO0FBRTdCLElBQUksQ0FBQywwQkFBMEIsRUFBRSxHQUFHLEVBQUU7SUFDcEMsTUFBTSxDQUFDLEdBQUcsRUFBRTtRQUNWLFFBQVE7UUFDUixNQUFNLEtBQUssR0FBRyxJQUFJLFlBQUssRUFBRSxDQUFDO1FBRTFCLFNBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtZQUMzQixTQUFTLEVBQUUsV0FBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztTQUNyRCxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztBQUMvRSxDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7SUFDOUIsTUFBTSxRQUFRLEdBQUcsMEJBQTBCLENBQUM7UUFDMUMsS0FBSyxFQUFFLHNDQUFzQztLQUM5QyxFQUFFLE9BQU8sQ0FBQyxFQUFFO1FBQ1gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDakQsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLEtBQUssR0FBRyxJQUFJLFlBQUssQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3pHLE1BQU0sR0FBRyxHQUFHLFNBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtRQUN2QyxTQUFTLEVBQUUsV0FBVztLQUN2QixDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0lBQ2xFLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUN4QyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2YsTUFBTTtnQkFDTixFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRTtnQkFDekIsc0VBQXNFO2FBQ3ZFLENBQUM7S0FDSCxDQUFDLENBQUM7SUFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUMsQ0FBQztBQU1ILFNBQVMsMEJBQTBCLENBQ2pDLFFBQWdDLEVBQ2hDLGNBQTREO0lBQzVELE1BQU0sUUFBUSxHQUFHLHNCQUFlLENBQUMsUUFBUSxDQUFDO0lBQzFDLHNCQUFlLENBQUMsUUFBUSxHQUFHLENBQUMsTUFBaUIsRUFBRSxPQUErQixFQUFFLEVBQUU7UUFDaEYsOEJBQThCO1FBQzlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFeEUsSUFBSSxjQUFjLEVBQUU7WUFDbEIsY0FBYyxDQUFDLE9BQU8sQ0FBQyxLQUFZLENBQUMsQ0FBQztTQUN0QztRQUVELE9BQU87WUFDTCxLQUFLLEVBQUU7Z0JBQ0wsR0FBRyxRQUFRO2FBQ2dCO1NBQzlCLENBQUM7SUFDSixDQUFDLENBQUM7SUFDRixPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxRQUFzRjtJQUNwSCxzQkFBZSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDdEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJy4uLy4uL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXIsIEdldENvbnRleHRWYWx1ZU9wdGlvbnMsIEdldENvbnRleHRWYWx1ZVJlc3VsdCwgTGF6eSwgU3RhY2sgfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJy4uLy4uL2N4LWFwaSc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IEtleSB9IGZyb20gJy4uL2xpYic7XG5cbnRlc3QoJ3JlcXVpcmVzIGNvbmNyZXRlIHZhbHVlcycsICgpID0+IHtcbiAgZXhwZWN0KCgpID0+IHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICBLZXkuZnJvbUxvb2t1cChzdGFjaywgJ0tleScsIHtcbiAgICAgIGFsaWFzTmFtZTogTGF6eS5zdHJpbmcoeyBwcm9kdWNlOiAoKSA9PiAnc29tZS1pZCcgfSksXG4gICAgfSk7XG4gIH0pLnRvVGhyb3coJ0FsbCBhcmd1bWVudHMgdG8gS2V5LmZyb21Mb29rdXAoKSBtdXN0IGJlIGNvbmNyZXRlIChubyBUb2tlbnMpJyk7XG59KTtcblxudGVzdCgncmV0dXJuIGNvcnJlY3Qga2V5JywgKCkgPT4ge1xuICBjb25zdCBwcmV2aW91cyA9IG1vY2tLZXlDb250ZXh0UHJvdmlkZXJXaXRoKHtcbiAgICBrZXlJZDogJzEyMzQ1Njc4LTEyMzQtMTIzNC0xMjM0LTEyMzQ1Njc4OTAxMicsXG4gIH0sIG9wdGlvbnMgPT4ge1xuICAgIGV4cGVjdChvcHRpb25zLmFsaWFzTmFtZSkudG9FcXVhbCgnYWxpYXMvZm9vJyk7XG4gIH0pO1xuXG4gIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGVudjogeyByZWdpb246ICd1cy1lYXN0LTEnLCBhY2NvdW50OiAnMTIzNDU2Nzg5MDEyJyB9IH0pO1xuICBjb25zdCBrZXkgPSBLZXkuZnJvbUxvb2t1cChzdGFjaywgJ0tleScsIHtcbiAgICBhbGlhc05hbWU6ICdhbGlhcy9mb28nLFxuICB9KTtcblxuICBleHBlY3Qoa2V5LmtleUlkKS50b0VxdWFsKCcxMjM0NTY3OC0xMjM0LTEyMzQtMTIzNC0xMjM0NTY3ODkwMTInKTtcbiAgZXhwZWN0KHN0YWNrLnJlc29sdmUoa2V5LmtleUFybikpLnRvRXF1YWwoe1xuICAgICdGbjo6Sm9pbic6IFsnJywgW1xuICAgICAgJ2FybjonLFxuICAgICAgeyBSZWY6ICdBV1M6OlBhcnRpdGlvbicgfSxcbiAgICAgICc6a21zOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6a2V5LzEyMzQ1Njc4LTEyMzQtMTIzNC0xMjM0LTEyMzQ1Njc4OTAxMicsXG4gICAgXV0sXG4gIH0pO1xuXG4gIHJlc3RvcmVDb250ZXh0UHJvdmlkZXIocHJldmlvdXMpO1xufSk7XG5cbmludGVyZmFjZSBNb2NrS2V5Q29udGV4dFJlc3BvbnNlIHtcbiAgcmVhZG9ubHkga2V5SWQ6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gbW9ja0tleUNvbnRleHRQcm92aWRlcldpdGgoXG4gIHJlc3BvbnNlOiBNb2NrS2V5Q29udGV4dFJlc3BvbnNlLFxuICBwYXJhbVZhbGlkYXRvcj86IChvcHRpb25zOiBjeHNjaGVtYS5LZXlDb250ZXh0UXVlcnkpID0+IHZvaWQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBDb250ZXh0UHJvdmlkZXIuZ2V0VmFsdWU7XG4gIENvbnRleHRQcm92aWRlci5nZXRWYWx1ZSA9IChfc2NvcGU6IENvbnN0cnVjdCwgb3B0aW9uczogR2V0Q29udGV4dFZhbHVlT3B0aW9ucykgPT4ge1xuICAgIC8vIGRvIHNvbWUgYmFzaWMgc2FuaXR5IGNoZWNrc1xuICAgIGV4cGVjdChvcHRpb25zLnByb3ZpZGVyKS50b0VxdWFsKGN4c2NoZW1hLkNvbnRleHRQcm92aWRlci5LRVlfUFJPVklERVIpO1xuXG4gICAgaWYgKHBhcmFtVmFsaWRhdG9yKSB7XG4gICAgICBwYXJhbVZhbGlkYXRvcihvcHRpb25zLnByb3BzIGFzIGFueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgfSBhcyBjeGFwaS5LZXlDb250ZXh0UmVzcG9uc2UsXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udGV4dFByb3ZpZGVyKHByZXZpb3VzOiAoc2NvcGU6IENvbnN0cnVjdCwgb3B0aW9uczogR2V0Q29udGV4dFZhbHVlT3B0aW9ucykgPT4gR2V0Q29udGV4dFZhbHVlUmVzdWx0KTogdm9pZCB7XG4gIENvbnRleHRQcm92aWRlci5nZXRWYWx1ZSA9IHByZXZpb3VzO1xufVxuIl19