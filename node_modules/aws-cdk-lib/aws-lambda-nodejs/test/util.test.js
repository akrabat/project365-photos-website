"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const fs = require("fs");
const path = require("path");
const util_1 = require("../lib/util");
beforeEach(() => {
    jest.clearAllMocks();
});
describe('callsites', () => {
    expect((0, util_1.callsites)()[0].getFileName()).toMatch(/\/test\/util.test.js$/);
});
describe('findUp', () => {
    test.skip('Starting at process.cwd()', () => {
        expect((0, util_1.findUp)('README.md')).toMatch(/aws-cdk-lib\/README.md$/);
    });
    test.skip('Non existing file', () => {
        expect((0, util_1.findUp)('non-existing-file.unknown')).toBe(undefined);
    });
    test.skip('Starting at a specific path', () => {
        expect((0, util_1.findUp)('util.test.ts', path.join(__dirname, 'integ-handlers'))).toMatch(/aws-lambda-nodejs\/test\/util.test.ts$/);
    });
    test.skip('Non existing file starting at a non existing relative path', () => {
        expect((0, util_1.findUp)('not-to-be-found.txt', 'non-existing/relative/path')).toBe(undefined);
    });
    test.skip('Starting at a relative path', () => {
        expect((0, util_1.findUp)('util.test.ts', 'aws-lambda-nodejs/test/integ-handlers')).toMatch(/aws-lambda-nodejs\/test\/util.test.ts$/);
    });
});
describe('findUpMultiple', () => {
    test.skip('Starting at process.cwd()', () => {
        const files = (0, util_1.findUpMultiple)(['README.md', 'package.json']);
        expect(files).toHaveLength(2);
        expect(files[0]).toMatch(/aws-cdk-lib\/README\.md$/);
        expect(files[1]).toMatch(/aws-cdk-lib\/package\.json$/);
    });
    test.skip('Non existing files', () => {
        expect((0, util_1.findUpMultiple)(['non-existing-file.unknown', 'non-existing-file.unknown2'])).toEqual([]);
    });
    test.skip('Existing and non existing files', () => {
        const files = (0, util_1.findUpMultiple)(['non-existing-file.unknown', 'README.md']);
        expect(files).toHaveLength(1);
        expect(files[0]).toMatch(/aws-cdk-lib\/README\.md$/);
    });
    test.skip('Starting at a specific path', () => {
        const files = (0, util_1.findUpMultiple)(['util.test.ts', 'function.test.ts'], path.join(__dirname, 'integ-handlers'));
        expect(files).toHaveLength(2);
        expect(files[0]).toMatch(/aws-lambda-nodejs\/test\/util\.test\.ts$/);
        expect(files[1]).toMatch(/aws-lambda-nodejs\/test\/function\.test\.ts$/);
    });
    test.skip('Non existing files starting at a non existing relative path', () => {
        expect((0, util_1.findUpMultiple)(['not-to-be-found.txt', 'not-to-be-found2.txt'], 'non-existing/relative/path')).toEqual([]);
    });
    test.skip('Starting at a relative path', () => {
        const files = (0, util_1.findUpMultiple)(['util.test.ts', 'function.test.ts'], 'aws-lambda-nodejs/test/integ-handlers');
        expect(files).toHaveLength(2);
        expect(files[0]).toMatch(/aws-lambda-nodejs\/test\/util\.test\.ts$/);
        expect(files[1]).toMatch(/aws-lambda-nodejs\/test\/function\.test\.ts$/);
    });
    test.skip('Files on multiple levels', () => {
        const files = (0, util_1.findUpMultiple)(['README.md', 'util.test.ts'], path.join(__dirname, 'integ-handlers'));
        expect(files).toHaveLength(1);
        expect(files[0]).toMatch(/aws-lambda-nodejs\/test\/util\.test\.ts$/);
    });
});
describe('exec', () => {
    test.skip('normal execution', () => {
        const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({
            status: 0,
            stderr: Buffer.from('stderr'),
            stdout: Buffer.from('stdout'),
            pid: 123,
            output: ['stdout', 'stderr'],
            signal: null,
        });
        const proc = (0, util_1.exec)('cmd', ['arg1', 'arg2'], { env: { KEY: 'value' } });
        expect(spawnSyncMock).toHaveBeenCalledWith('cmd', ['arg1', 'arg2'], { env: { KEY: 'value' } });
        expect(proc.stdout.toString()).toBe('stdout');
        spawnSyncMock.mockRestore();
    });
    test.skip('non zero status', () => {
        const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({
            status: 999,
            stderr: Buffer.from('error occured'),
            stdout: Buffer.from('stdout'),
            pid: 123,
            output: ['stdout', 'stderr'],
            signal: null,
        });
        expect(() => (0, util_1.exec)('cmd', ['arg1', 'arg2'])).toThrow('error occured');
        spawnSyncMock.mockRestore();
    });
    test.skip('with error', () => {
        const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({
            error: new Error('bad error'),
            status: 0,
            stderr: Buffer.from('stderr'),
            stdout: Buffer.from('stdout'),
            pid: 123,
            output: ['stdout', 'stderr'],
            signal: null,
        });
        expect(() => (0, util_1.exec)('cmd', ['arg1', 'arg2'])).toThrow(new Error('bad error'));
        spawnSyncMock.mockRestore();
    });
});
describe('extractDependencies', () => {
    test.skip('with dependencies referenced in package.json', () => {
        const deps = (0, util_1.extractDependencies)(path.join(__dirname, 'testpackage.json'), ['@aws-cdk/aws-lambda', '@aws-cdk/core']);
        expect(Object.keys(deps)).toEqual([
            '@aws-cdk/aws-lambda',
            '@aws-cdk/core',
        ]);
    });
    test.skip('with transitive dependencies', () => {
        expect((0, util_1.extractDependencies)(path.join(__dirname, 'testpackage.json'), ['typescript'])).toEqual({
            // eslint-disable-next-line @typescript-eslint/no-require-imports, import/no-extraneous-dependencies
            typescript: require('typescript/package.json').version,
        });
    });
    test.skip('with unknown dependency', () => {
        expect(() => (0, util_1.extractDependencies)(path.join(__dirname, 'testpackage.json'), ['unknown'])).toThrow(/Cannot extract version for module 'unknown'/);
    });
    test.skip('with file dependency', () => {
        const pkgPath = path.join(__dirname, 'package-file.json');
        fs.writeFileSync(pkgPath, JSON.stringify({
            dependencies: {
                'my-module': 'file:../../core',
            },
        }));
        expect((0, util_1.extractDependencies)(pkgPath, ['my-module'])).toEqual({
            'my-module': expect.stringMatching(/packages\/aws-cdk-lib\/core/),
        });
        fs.unlinkSync(pkgPath);
    });
});
describe('getTsconfigCompilerOptions', () => {
    test.skip('should extract compiler options and returns as string', () => {
        const tsconfig = path.join(__dirname, 'testtsconfig.json');
        const compilerOptions = (0, util_1.getTsconfigCompilerOptions)(tsconfig);
        expect(compilerOptions).toEqual([
            '--alwaysStrict',
            '--charset utf8',
            '--declaration',
            '--declarationMap false',
            '--experimentalDecorators',
            '--incremental false',
            '--inlineSourceMap',
            '--inlineSources',
            '--lib es2020',
            '--module CommonJS',
            '--newLine lf',
            '--noEmitOnError',
            '--noFallthroughCasesInSwitch',
            '--noImplicitAny',
            '--noImplicitReturns',
            '--noImplicitThis',
            '--noUnusedLocals',
            '--noUnusedParameters',
            '--outDir ./',
            '--resolveJsonModule',
            '--rootDir ./',
            '--strict',
            '--strictNullChecks',
            '--strictPropertyInitialization',
            '--stripInternal false',
            '--target ES2020',
        ].join(' '));
    });
    test.skip('should extract compiler options with extended config overriding', () => {
        const tsconfig = path.join(__dirname, 'testtsconfig-extended.json');
        const compilerOptions = (0, util_1.getTsconfigCompilerOptions)(tsconfig);
        expect(compilerOptions).toEqual([
            '--alwaysStrict',
            '--charset utf8',
            '--declaration',
            '--declarationMap false',
            '--experimentalDecorators',
            '--incremental false',
            '--inlineSourceMap',
            '--inlineSources',
            '--lib es2020',
            '--module CommonJS',
            '--newLine lf',
            '--noEmitOnError',
            '--noFallthroughCasesInSwitch',
            '--noImplicitAny',
            '--noImplicitReturns',
            '--noImplicitThis',
            '--noUnusedLocals',
            '--noUnusedParameters',
            '--outDir ./',
            '--resolveJsonModule',
            '--rootDir ./',
            '--strict',
            '--strictNullChecks',
            '--strictPropertyInitialization',
            '--stripInternal false',
            '--target ES2022',
        ].join(' '));
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidXRpbC50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0NBQStDO0FBQy9DLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0Isc0NBQXVIO0FBRXZILFVBQVUsQ0FBQyxHQUFHLEVBQUU7SUFDZCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDdkIsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRTtJQUN6QixNQUFNLENBQUMsSUFBQSxnQkFBUyxHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUN4RSxDQUFDLENBQUMsQ0FBQztBQUVILFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsMkJBQTJCLEVBQUUsR0FBRyxFQUFFO1FBQzFDLE1BQU0sQ0FBQyxJQUFBLGFBQU0sRUFBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQ2pFLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDbEMsTUFBTSxDQUFDLElBQUEsYUFBTSxFQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUQsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLDZCQUE2QixFQUFFLEdBQUcsRUFBRTtRQUM1QyxNQUFNLENBQUMsSUFBQSxhQUFNLEVBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO0lBQzNILENBQUMsQ0FB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QTRCLENBQUMsQ0FBQztRQUNwRSxNQUFNLGVBQWUsR0FBRyxJQUFBLGlDQUEwQixFQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdELE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUM7WUFDOUIsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtZQUNoQixlQUFlO1lBQ2Ysd0JBQXdCO1lBQ3hCLDBCQUEwQjtZQUMxQixxQkFBcUI7WUFDckIsbUJBQW1CO1lBQ25CLGlCQUFpQjtZQUNqQixjQUFjO1lBQ2QsbUJBQW1CO1lBQ25CLGNBQWM7WUFDZCxpQkFBaUI7WUFDakIsOEJBQThCO1lBQzlCLGlCQUFpQjtZQUNqQixxQkFBcUI7WUFDckIsa0JBQWtCO1lBQ2xCLGtCQUFrQjtZQUNsQixzQkFBc0I7WUFDdEIsYUFBYTtZQUNiLHFCQUFxQjtZQUNyQixjQUFjO1lBQ2QsVUFBVTtZQUNWLG9CQUFvQjtZQUNwQixnQ0FBZ0M7WUFDaEMsdUJBQXVCO1lBQ3ZCLGlCQUFpQjtTQUNsQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2YsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY2FsbHNpdGVzLCBleGVjLCBleHRyYWN0RGVwZW5kZW5jaWVzLCBmaW5kVXAsIGZpbmRVcE11bHRpcGxlLCBnZXRUc2NvbmZpZ0NvbXBpbGVyT3B0aW9ucyB9IGZyb20gJy4uL2xpYi91dGlsJztcblxuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xufSk7XG5cbmRlc2NyaWJlKCdjYWxsc2l0ZXMnLCAoKSA9PiB7XG4gIGV4cGVjdChjYWxsc2l0ZXMoKVswXS5nZXRGaWxlTmFtZSgpKS50b01hdGNoKC9cXC90ZXN0XFwvdXRpbC50ZXN0LmpzJC8pO1xufSk7XG5cbmRlc2NyaWJlKCdmaW5kVXAnLCAoKSA9PiB7XG4gIHRlc3Quc2tpcCgnU3RhcnRpbmcgYXQgcHJvY2Vzcy5jd2QoKScsICgpID0+IHtcbiAgICBleHBlY3QoZmluZFVwKCdSRUFETUUubWQnKSkudG9NYXRjaCgvYXdzLWNkay1saWJcXC9SRUFETUUubWQkLyk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnTm9uIGV4aXN0aW5nIGZpbGUnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbmRVcCgnbm9uLWV4aXN0aW5nLWZpbGUudW5rbm93bicpKS50b0JlKHVuZGVmaW5lZCk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnU3RhcnRpbmcgYXQgYSBzcGVjaWZpYyBwYXRoJywgKCkgPT4ge1xuICAgIGV4cGVjdChmaW5kVXAoJ3V0aWwudGVzdC50cycsIHBhdGguam9pbihfX2Rpcm5hbWUsICdpbnRlZy1oYW5kbGVycycpKSkudG9NYXRjaCgvYXdzLWxhbWJkYS1ub2RlanNcXC90ZXN0XFwvdXRpbC50ZXN0LnRzJC8pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ05vbiBleGlzdGluZyBmaWxlIHN0YXJ0aW5nIGF0IGEgbm9uIGV4aXN0aW5nIHJlbGF0aXZlIHBhdGgnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbmRVcCgnbm90LXRvLWJlLWZvdW5kLnR4dCcsICdub24tZXhpc3RpbmcvcmVsYXRpdmUvcGF0aCcpKS50b0JlKHVuZGVmaW5lZCk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnU3RhcnRpbmcgYXQgYSByZWxhdGl2ZSBwYXRoJywgKCkgPT4ge1xuICAgIGV4cGVjdChmaW5kVXAoJ3V0aWwudGVzdC50cycsICdhd3MtbGFtYmRhLW5vZGVqcy90ZXN0L2ludGVnLWhhbmRsZXJzJykpLnRvTWF0Y2goL2F3cy1sYW1iZGEtbm9kZWpzXFwvdGVzdFxcL3V0aWwudGVzdC50cyQvKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2ZpbmRVcE11bHRpcGxlJywgKCkgPT4ge1xuICB0ZXN0LnNraXAoJ1N0YXJ0aW5nIGF0IHByb2Nlc3MuY3dkKCknLCAoKSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBmaW5kVXBNdWx0aXBsZShbJ1JFQURNRS5tZCcsICdwYWNrYWdlLmpzb24nXSk7XG4gICAgZXhwZWN0KGZpbGVzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgZXhwZWN0KGZpbGVzWzBdKS50b01hdGNoKC9hd3MtY2RrLWxpYlxcL1JFQURNRVxcLm1kJC8pO1xuICAgIGV4cGVjdChmaWxlc1sxXSkudG9NYXRjaCgvYXdzLWNkay1saWJcXC9wYWNrYWdlXFwuanNvbiQvKTtcbiAgfSk7XG5cbiAgdGVzdC5za2lwKCdOb24gZXhpc3RpbmcgZmlsZXMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGZpbmRVcE11bHRpcGxlKFsnbm9uLWV4aXN0aW5nLWZpbGUudW5rbm93bicsICdub24tZXhpc3RpbmctZmlsZS51bmtub3duMiddKSkudG9FcXVhbChbXSk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnRXhpc3RpbmcgYW5kIG5vbiBleGlzdGluZyBmaWxlcycsICgpID0+IHtcbiAgICBjb25zdCBmaWxlcyA9IGZpbmRVcE11bHRpcGxlKFsnbm9uLWV4aXN0aW5nLWZpbGUudW5rbm93bicsICdSRUFETUUubWQnXSk7XG4gICAgZXhwZWN0KGZpbGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgZXhwZWN0KGZpbGVzWzBdKS50b01hdGNoKC9hd3MtY2RrLWxpYlxcL1JFQURNRVxcLm1kJC8pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ1N0YXJ0aW5nIGF0IGEgc3BlY2lmaWMgcGF0aCcsICgpID0+IHtcbiAgICBjb25zdCBmaWxlcyA9IGZpbmRVcE11bHRpcGxlKFsndXRpbC50ZXN0LnRzJywgJ2Z1bmN0aW9uLnRlc3QudHMnXSwgcGF0aC5qb2luKF9fZGlybmFtZSwgJ2ludGVnLWhhbmRsZXJzJykpO1xuICAgIGV4cGVjdChmaWxlcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgIGV4cGVjdChmaWxlc1swXSkudG9NYXRjaCgvYXdzLWxhbWJkYS1ub2RlanNcXC90ZXN0XFwvdXRpbFxcLnRlc3RcXC50cyQvKTtcbiAgICBleHBlY3QoZmlsZXNbMV0pLnRvTWF0Y2goL2F3cy1sYW1iZGEtbm9kZWpzXFwvdGVzdFxcL2Z1bmN0aW9uXFwudGVzdFxcLnRzJC8pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ05vbiBleGlzdGluZyBmaWxlcyBzdGFydGluZyBhdCBhIG5vbiBleGlzdGluZyByZWxhdGl2ZSBwYXRoJywgKCkgPT4ge1xuICAgIGV4cGVjdChmaW5kVXBNdWx0aXBsZShbJ25vdC10by1iZS1mb3VuZC50eHQnLCAnbm90LXRvLWJlLWZvdW5kMi50eHQnXSwgJ25vbi1leGlzdGluZy9yZWxhdGl2ZS9wYXRoJykpLnRvRXF1YWwoW10pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ1N0YXJ0aW5nIGF0IGEgcmVsYXRpdmUgcGF0aCcsICgpID0+IHtcbiAgICBjb25zdCBmaWxlcyA9IGZpbmRVcE11bHRpcGxlKFsndXRpbC50ZXN0LnRzJywgJ2Z1bmN0aW9uLnRlc3QudHMnXSwgJ2F3cy1sYW1iZGEtbm9kZWpzL3Rlc3QvaW50ZWctaGFuZGxlcnMnKTtcbiAgICBleHBlY3QoZmlsZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICBleHBlY3QoZmlsZXNbMF0pLnRvTWF0Y2goL2F3cy1sYW1iZGEtbm9kZWpzXFwvdGVzdFxcL3V0aWxcXC50ZXN0XFwudHMkLyk7XG4gICAgZXhwZWN0KGZpbGVzWzFdKS50b01hdGNoKC9hd3MtbGFtYmRhLW5vZGVqc1xcL3Rlc3RcXC9mdW5jdGlvblxcLnRlc3RcXC50cyQvKTtcbiAgfSk7XG5cbiAgdGVzdC5za2lwKCdGaWxlcyBvbiBtdWx0aXBsZSBsZXZlbHMnLCAoKSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBmaW5kVXBNdWx0aXBsZShbJ1JFQURNRS5tZCcsICd1dGlsLnRlc3QudHMnXSwgcGF0aC5qb2luKF9fZGlybmFtZSwgJ2ludGVnLWhhbmRsZXJzJykpO1xuICAgIGV4cGVjdChmaWxlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgIGV4cGVjdChmaWxlc1swXSkudG9NYXRjaCgvYXdzLWxhbWJkYS1ub2RlanNcXC90ZXN0XFwvdXRpbFxcLnRlc3RcXC50cyQvKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2V4ZWMnLCAoKSA9PiB7XG4gIHRlc3Quc2tpcCgnbm9ybWFsIGV4ZWN1dGlvbicsICgpID0+IHtcbiAgICBjb25zdCBzcGF3blN5bmNNb2NrID0gamVzdC5zcHlPbihjaGlsZF9wcm9jZXNzLCAnc3Bhd25TeW5jJykubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHN0YXR1czogMCxcbiAgICAgIHN0ZGVycjogQnVmZmVyLmZyb20oJ3N0ZGVycicpLFxuICAgICAgc3Rkb3V0OiBCdWZmZXIuZnJvbSgnc3Rkb3V0JyksXG4gICAgICBwaWQ6IDEyMyxcbiAgICAgIG91dHB1dDogWydzdGRvdXQnLCAnc3RkZXJyJ10sXG4gICAgICBzaWduYWw6IG51bGwsXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm9jID0gZXhlYyhcbiAgICAgICdjbWQnLFxuICAgICAgWydhcmcxJywgJ2FyZzInXSxcbiAgICAgIHsgZW52OiB7IEtFWTogJ3ZhbHVlJyB9IH0sXG4gICAgKTtcblxuICAgIGV4cGVjdChzcGF3blN5bmNNb2NrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICdjbWQnLFxuICAgICAgWydhcmcxJywgJ2FyZzInXSxcbiAgICAgIHsgZW52OiB7IEtFWTogJ3ZhbHVlJyB9IH0sXG4gICAgKTtcbiAgICBleHBlY3QocHJvYy5zdGRvdXQudG9TdHJpbmcoKSkudG9CZSgnc3Rkb3V0Jyk7XG5cbiAgICBzcGF3blN5bmNNb2NrLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnbm9uIHplcm8gc3RhdHVzJywgKCkgPT4ge1xuICAgIGNvbnN0IHNwYXduU3luY01vY2sgPSBqZXN0LnNweU9uKGNoaWxkX3Byb2Nlc3MsICdzcGF3blN5bmMnKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgc3RhdHVzOiA5OTksXG4gICAgICBzdGRlcnI6IEJ1ZmZlci5mcm9tKCdlcnJvciBvY2N1cmVkJyksXG4gICAgICBzdGRvdXQ6IEJ1ZmZlci5mcm9tKCdzdGRvdXQnKSxcbiAgICAgIHBpZDogMTIzLFxuICAgICAgb3V0cHV0OiBbJ3N0ZG91dCcsICdzdGRlcnInXSxcbiAgICAgIHNpZ25hbDogbnVsbCxcbiAgICB9KTtcblxuICAgIGV4cGVjdCgoKSA9PiBleGVjKCdjbWQnLCBbJ2FyZzEnLCAnYXJnMiddKSkudG9UaHJvdygnZXJyb3Igb2NjdXJlZCcpO1xuXG4gICAgc3Bhd25TeW5jTW9jay5tb2NrUmVzdG9yZSgpO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ3dpdGggZXJyb3InLCAoKSA9PiB7XG4gICAgY29uc3Qgc3Bhd25TeW5jTW9jayA9IGplc3Quc3B5T24oY2hpbGRfcHJvY2VzcywgJ3NwYXduU3luYycpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBlcnJvcjogbmV3IEVycm9yKCdiYWQgZXJyb3InKSxcbiAgICAgIHN0YXR1czogMCxcbiAgICAgIHN0ZGVycjogQnVmZmVyLmZyb20oJ3N0ZGVycicpLFxuICAgICAgc3Rkb3V0OiBCdWZmZXIuZnJvbSgnc3Rkb3V0JyksXG4gICAgICBwaWQ6IDEyMyxcbiAgICAgIG91dHB1dDogWydzdGRvdXQnLCAnc3RkZXJyJ10sXG4gICAgICBzaWduYWw6IG51bGwsXG4gICAgfSk7XG5cbiAgICBleHBlY3QoKCkgPT4gZXhlYygnY21kJywgWydhcmcxJywgJ2FyZzInXSkpLnRvVGhyb3cobmV3IEVycm9yKCdiYWQgZXJyb3InKSk7XG5cbiAgICBzcGF3blN5bmNNb2NrLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdleHRyYWN0RGVwZW5kZW5jaWVzJywgKCkgPT4ge1xuICB0ZXN0LnNraXAoJ3dpdGggZGVwZW5kZW5jaWVzIHJlZmVyZW5jZWQgaW4gcGFja2FnZS5qc29uJywgKCkgPT4ge1xuICAgIGNvbnN0IGRlcHMgPSBleHRyYWN0RGVwZW5kZW5jaWVzKFxuICAgICAgcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3RwYWNrYWdlLmpzb24nKSxcbiAgICAgIFsnQGF3cy1jZGsvYXdzLWxhbWJkYScsICdAYXdzLWNkay9jb3JlJ10sXG4gICAgKTtcbiAgICBleHBlY3QoT2JqZWN0LmtleXMoZGVwcykpLnRvRXF1YWwoW1xuICAgICAgJ0Bhd3MtY2RrL2F3cy1sYW1iZGEnLFxuICAgICAgJ0Bhd3MtY2RrL2NvcmUnLFxuICAgIF0pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ3dpdGggdHJhbnNpdGl2ZSBkZXBlbmRlbmNpZXMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGV4dHJhY3REZXBlbmRlbmNpZXMoXG4gICAgICBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdHBhY2thZ2UuanNvbicpLFxuICAgICAgWyd0eXBlc2NyaXB0J10sXG4gICAgKSkudG9FcXVhbCh7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICB0eXBlc2NyaXB0OiByZXF1aXJlKCd0eXBlc2NyaXB0L3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnd2l0aCB1bmtub3duIGRlcGVuZGVuY3knLCAoKSA9PiB7XG4gICAgZXhwZWN0KCgpID0+IGV4dHJhY3REZXBlbmRlbmNpZXMoXG4gICAgICBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdHBhY2thZ2UuanNvbicpLFxuICAgICAgWyd1bmtub3duJ10sXG4gICAgKSkudG9UaHJvdygvQ2Fubm90IGV4dHJhY3QgdmVyc2lvbiBmb3IgbW9kdWxlICd1bmtub3duJy8pO1xuICB9KTtcblxuICB0ZXN0LnNraXAoJ3dpdGggZmlsZSBkZXBlbmRlbmN5JywgKCkgPT4ge1xuICAgIGNvbnN0IHBrZ1BhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAncGFja2FnZS1maWxlLmpzb24nKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBrZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICAnbXktbW9kdWxlJzogJ2ZpbGU6Li4vLi4vY29yZScsXG4gICAgICB9LFxuICAgIH0pKTtcblxuICAgIGV4cGVjdChleHRyYWN0RGVwZW5kZW5jaWVzKHBrZ1BhdGgsIFsnbXktbW9kdWxlJ10pKS50b0VxdWFsKHtcbiAgICAgICdteS1tb2R1bGUnOiBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL3BhY2thZ2VzXFwvYXdzLWNkay1saWJcXC9jb3JlLyksXG4gICAgfSk7XG5cbiAgICBmcy51bmxpbmtTeW5jKHBrZ1BhdGgpO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnZ2V0VHNjb25maWdDb21waWxlck9wdGlvbnMnLCAoKSA9PiB7XG4gIHRlc3Quc2tpcCgnc2hvdWxkIGV4dHJhY3QgY29tcGlsZXIgb3B0aW9ucyBhbmQgcmV0dXJucyBhcyBzdHJpbmcnLCAoKSA9PiB7XG4gICAgY29uc3QgdHNjb25maWcgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdHRzY29uZmlnLmpzb24nKTtcbiAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBnZXRUc2NvbmZpZ0NvbXBpbGVyT3B0aW9ucyh0c2NvbmZpZyk7XG4gICAgZXhwZWN0KGNvbXBpbGVyT3B0aW9ucykudG9FcXVhbChbXG4gICAgICAnLS1hbHdheXNTdHJpY3QnLFxuICAgICAgJy0tY2hhcnNldCB1dGY4JyxcbiAgICAgICctLWRlY2xhcmF0aW9uJyxcbiAgICAgICctLWRlY2xhcmF0aW9uTWFwIGZhbHNlJyxcbiAgICAgICctLWV4cGVyaW1lbnRhbERlY29yYXRvcnMnLFxuICAgICAgJy0taW5jcmVtZW50YWwgZmFsc2UnLFxuICAgICAgJy0taW5saW5lU291cmNlTWFwJyxcbiAgICAgICctLWlubGluZVNvdXJjZXMnLFxuICAgICAgJy0tbGliIGVzMjAyMCcsXG4gICAgICAnLS1tb2R1bGUgQ29tbW9uSlMnLFxuICAgICAgJy0tbmV3TGluZSBsZicsXG4gICAgICAnLS1ub0VtaXRPbkVycm9yJyxcbiAgICAgICctLW5vRmFsbHRocm91Z2hDYXNlc0luU3dpdGNoJyxcbiAgICAgICctLW5vSW1wbGljaXRBbnknLFxuICAgICAgJy0tbm9JbXBsaWNpdFJldHVybnMnLFxuICAgICAgJy0tbm9JbXBsaWNpdFRoaXMnLFxuICAgICAgJy0tbm9VbnVzZWRMb2NhbHMnLFxuICAgICAgJy0tbm9VbnVzZWRQYXJhbWV0ZXJzJyxcbiAgICAgICctLW91dERpciAuLycsXG4gICAgICAnLS1yZXNvbHZlSnNvbk1vZHVsZScsXG4gICAgICAnLS1yb290RGlyIC4vJyxcbiAgICAgICctLXN0cmljdCcsXG4gICAgICAnLS1zdHJpY3ROdWxsQ2hlY2tzJyxcbiAgICAgICctLXN0cmljdFByb3BlcnR5SW5pdGlhbGl6YXRpb24nLFxuICAgICAgJy0tc3RyaXBJbnRlcm5hbCBmYWxzZScsXG4gICAgICAnLS10YXJnZXQgRVMyMDIwJyxcbiAgICBdLmpvaW4oJyAnKSk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcCgnc2hvdWxkIGV4dHJhY3QgY29tcGlsZXIgb3B0aW9ucyB3aXRoIGV4dGVuZGVkIGNvbmZpZyBvdmVycmlkaW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IHRzY29uZmlnID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3R0c2NvbmZpZy1leHRlbmRlZC5qc29uJyk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gZ2V0VHNjb25maWdDb21waWxlck9wdGlvbnModHNjb25maWcpO1xuICAgIGV4cGVjdChjb21waWxlck9wdGlvbnMpLnRvRXF1YWwoW1xuICAgICAgJy0tYWx3YXlzU3RyaWN0JyxcbiAgICAgICctLWNoYXJzZXQgdXRmOCcsXG4gICAgICAnLS1kZWNsYXJhdGlvbicsXG4gICAgICAnLS1kZWNsYXJhdGlvbk1hcCBmYWxzZScsXG4gICAgICAnLS1leHBlcmltZW50YWxEZWNvcmF0b3JzJyxcbiAgICAgICctLWluY3JlbWVudGFsIGZhbHNlJyxcbiAgICAgICctLWlubGluZVNvdXJjZU1hcCcsXG4gICAgICAnLS1pbmxpbmVTb3VyY2VzJyxcbiAgICAgICctLWxpYiBlczIwMjAnLFxuICAgICAgJy0tbW9kdWxlIENvbW1vbkpTJyxcbiAgICAgICctLW5ld0xpbmUgbGYnLFxuICAgICAgJy0tbm9FbWl0T25FcnJvcicsXG4gICAgICAnLS1ub0ZhbGx0aHJvdWdoQ2FzZXNJblN3aXRjaCcsXG4gICAgICAnLS1ub0ltcGxpY2l0QW55JyxcbiAgICAgICctLW5vSW1wbGljaXRSZXR1cm5zJyxcbiAgICAgICctLW5vSW1wbGljaXRUaGlzJyxcbiAgICAgICctLW5vVW51c2VkTG9jYWxzJyxcbiAgICAgICctLW5vVW51c2VkUGFyYW1ldGVycycsXG4gICAgICAnLS1vdXREaXIgLi8nLFxuICAgICAgJy0tcmVzb2x2ZUpzb25Nb2R1bGUnLFxuICAgICAgJy0tcm9vdERpciAuLycsXG4gICAgICAnLS1zdHJpY3QnLFxuICAgICAgJy0tc3RyaWN0TnVsbENoZWNrcycsXG4gICAgICAnLS1zdHJpY3RQcm9wZXJ0eUluaXRpYWxpemF0aW9uJyxcbiAgICAgICctLXN0cmlwSW50ZXJuYWwgZmFsc2UnLFxuICAgICAgJy0tdGFyZ2V0IEVTMjAyMicsXG4gICAgXS5qb2luKCcgJykpO1xuICB9KTtcbn0pO1xuIl19