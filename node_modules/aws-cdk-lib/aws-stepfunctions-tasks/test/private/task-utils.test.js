"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aws_stepfunctions_1 = require("../../../aws-stepfunctions");
const cdk = require("../../../core");
const task_utils_1 = require("../../lib/private/task-utils");
describe('Task utils', () => {
    describe('integration pattern validation', () => {
        test('supported integration pattern', () => {
            // GIVEN
            const supportedPatterns = [aws_stepfunctions_1.IntegrationPattern.REQUEST_RESPONSE];
            expect(() => {
                (0, task_utils_1.validatePatternSupported)(aws_stepfunctions_1.IntegrationPattern.REQUEST_RESPONSE, supportedPatterns);
            }).not.toThrow();
        });
        test('fails on unsupported integration pattern', () => {
            // GIVEN
            const supportedPatterns = [aws_stepfunctions_1.IntegrationPattern.RUN_JOB];
            expect(() => {
                (0, task_utils_1.validatePatternSupported)(aws_stepfunctions_1.IntegrationPattern.WAIT_FOR_TASK_TOKEN, supportedPatterns);
            }).toThrowError(/Unsupported service integration pattern. Supported Patterns: RUN_JOB. Received: WAIT_FOR_TASK_TOKEN/);
        });
    });
    describe('integration resource Arn', () => {
        let service;
        let api;
        let stack;
        beforeEach(() => {
            // GIVEN
            service = 'lambda';
            api = 'invoke';
            stack = new cdk.Stack();
        });
        test('get resourceArn for a request/response integration pattern', () => {
            // WHEN
            const resourceArn = (0, task_utils_1.integrationResourceArn)(service, api, aws_stepfunctions_1.IntegrationPattern.REQUEST_RESPONSE);
            // THEN
            expect(stack.resolve(resourceArn)).toEqual({
                'Fn::Join': [
                    '',
                    [
                        'arn:',
                        { Ref: 'AWS::Partition' },
                        ':states:::lambda:invoke',
                    ],
                ],
            });
        });
        test('get resourceArn for a run job integration pattern', () => {
            // WHEN
            const resourceArn = (0, task_utils_1.integrationResourceArn)(service, api, aws_stepfunctions_1.IntegrationPattern.RUN_JOB);
            // THEN
            expect(stack.resolve(resourceArn)).toEqual({
                'Fn::Join': [
                    '',
                    [
                        'arn:',
                        { Ref: 'AWS::Partition' },
                        ':states:::lambda:invoke.sync',
                    ],
                ],
            });
        });
        test('get resourceArn for a wait for task token integration pattern', () => {
            // WHEN
            const resourceArn = (0, task_utils_1.integrationResourceArn)(service, api, aws_stepfunctions_1.IntegrationPattern.WAIT_FOR_TASK_TOKEN);
            // THEN
            expect(stack.resolve(resourceArn)).toEqual({
                'Fn::Join': [
                    '',
                    [
                        'arn:',
                        { Ref: 'AWS::Partition' },
                        ':states:::lambda:invoke.waitForTaskToken',
                    ],
                ],
            });
        });
        test('fails when service or api is not specified', () => {
            expect(() => {
                (0, task_utils_1.integrationResourceArn)(service, '', aws_stepfunctions_1.IntegrationPattern.RUN_JOB);
            }).toThrow(/Both 'service' and 'api' must be provided to build the resource ARN./);
            expect(() => {
                (0, task_utils_1.integrationResourceArn)('', api, aws_stepfunctions_1.IntegrationPattern.RUN_JOB);
            }).toThrow(/Both 'service' and 'api' must be provided to build the resource ARN./);
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay11dGlscy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGFzay11dGlscy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsa0VBQWdFO0FBQ2hFLHFDQUFxQztBQUNyQyw2REFBZ0c7QUFFaEcsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7SUFDMUIsUUFBUSxDQUFDLGdDQUFnQyxFQUFFLEdBQUcsRUFBRTtRQUM5QyxJQUFJLENBQUMsK0JBQStCLEVBQUUsR0FBRyxFQUFFO1lBQ3pDLFFBQVE7WUFDUixNQUFNLGlCQUFpQixHQUF5QixDQUFDLHNDQUFrQixDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFFdEYsTUFBTSxDQUFFLEdBQUcsRUFBRTtnQkFDWCxJQUFBLHFDQUF3QixFQUFDLHNDQUFrQixDQUFDLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDbkYsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLDBDQUEwQyxFQUFFLEdBQUcsRUFBRTtZQUNwRCxRQUFRO1lBQ1IsTUFBTSxpQkFBaUIsR0FBeUIsQ0FBQyxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUU3RSxNQUFNLENBQUUsR0FBRyxFQUFFO2dCQUNYLElBQUEscUNBQXdCLEVBQUMsc0NBQWtCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUN0RixDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMscUdBQXFHLENBQUMsQ0FBQztRQUN6SCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDBCQUEwQixFQUFFLEdBQUcsRUFBRTtRQUV4QyxJQUFJLE9BQWUsQ0FBQztRQUNwQixJQUFJLEdBQVcsQ0FBQztRQUNoQixJQUFJLEtBQWdCLENBQUM7UUFFckIsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLFFBQVE7WUFDUixPQUFPLEdBQUcsUUFBUSxDQUFDO1lBQ25CLEdBQUcsR0FBRyxRQUFRLENBQUM7WUFDZixLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsNERBQTRELEVBQUUsR0FBRyxFQUFFO1lBQ3RFLE9BQU87WUFDUCxNQUFNLFdBQVcsR0FBRyxJQUFBLG1DQUFzQixFQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsc0NBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUU5RixPQUFPO1lBQ1AsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQ3pDLFVBQVUsRUFBRTtvQkFDVixFQUFFO29CQUNGO3dCQUNFLE1BQU07d0JBQ04sRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUU7d0JBQ3pCLHlCQUF5QjtxQkFDMUI7aUJBQ0Y7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxtREFBbUQsRUFBRSxHQUFHLEVBQUU7WUFDN0QsT0FBTztZQUNQLE1BQU0sV0FBVyxHQUFHLElBQUEsbUNBQXNCLEVBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUVyRixPQUFPO1lBQ1AsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQ3pDLFVBQVUsRUFBRTtvQkFDVixFQUFFO29CQUNGO3dCQUNFLE1BQU07d0JBQ04sRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUU7d0JBQ3pCLDhCQUE4QjtxQkFDL0I7aUJBQ0Y7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQywrREFBK0QsRUFBRSxHQUFHLEVBQUU7WUFDekUsT0FBTztZQUNQLE1BQU0sV0FBVyxHQUFHLElBQUEsbUNBQXNCLEVBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxzQ0FBa0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBRWpHLE9BQU87WUFDUCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFDekMsVUFBVSxFQUFFO29CQUNWLEVBQUU7b0JBQ0Y7d0JBQ0UsTUFBTTt3QkFDTixFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRTt3QkFDekIsMENBQTBDO3FCQUMzQztpQkFDRjthQUNGLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLDRDQUE0QyxFQUFFLEdBQUcsRUFBRTtZQUN0RCxNQUFNLENBQUMsR0FBRyxFQUFFO2dCQUNWLElBQUEsbUNBQXNCLEVBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNsRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsc0VBQXNFLENBQUMsQ0FBQztZQUVuRixNQUFNLENBQUMsR0FBRyxFQUFFO2dCQUNWLElBQUEsbUNBQXNCLEVBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5RCxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsc0VBQXNFLENBQUMsQ0FBQztRQUNyRixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUwsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlZ3JhdGlvblBhdHRlcm4gfSBmcm9tICcuLi8uLi8uLi9hd3Mtc3RlcGZ1bmN0aW9ucyc7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBpbnRlZ3JhdGlvblJlc291cmNlQXJuLCB2YWxpZGF0ZVBhdHRlcm5TdXBwb3J0ZWQgfSBmcm9tICcuLi8uLi9saWIvcHJpdmF0ZS90YXNrLXV0aWxzJztcblxuZGVzY3JpYmUoJ1Rhc2sgdXRpbHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdpbnRlZ3JhdGlvbiBwYXR0ZXJuIHZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc3VwcG9ydGVkIGludGVncmF0aW9uIHBhdHRlcm4nLCAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgY29uc3Qgc3VwcG9ydGVkUGF0dGVybnM6IEludGVncmF0aW9uUGF0dGVybltdID0gW0ludGVncmF0aW9uUGF0dGVybi5SRVFVRVNUX1JFU1BPTlNFXTtcblxuICAgICAgZXhwZWN0KCAoKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblN1cHBvcnRlZChJbnRlZ3JhdGlvblBhdHRlcm4uUkVRVUVTVF9SRVNQT05TRSwgc3VwcG9ydGVkUGF0dGVybnMpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2ZhaWxzIG9uIHVuc3VwcG9ydGVkIGludGVncmF0aW9uIHBhdHRlcm4nLCAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgY29uc3Qgc3VwcG9ydGVkUGF0dGVybnM6IEludGVncmF0aW9uUGF0dGVybltdID0gW0ludGVncmF0aW9uUGF0dGVybi5SVU5fSk9CXTtcblxuICAgICAgZXhwZWN0KCAoKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblN1cHBvcnRlZChJbnRlZ3JhdGlvblBhdHRlcm4uV0FJVF9GT1JfVEFTS19UT0tFTiwgc3VwcG9ydGVkUGF0dGVybnMpO1xuICAgICAgfSkudG9UaHJvd0Vycm9yKC9VbnN1cHBvcnRlZCBzZXJ2aWNlIGludGVncmF0aW9uIHBhdHRlcm4uIFN1cHBvcnRlZCBQYXR0ZXJuczogUlVOX0pPQi4gUmVjZWl2ZWQ6IFdBSVRfRk9SX1RBU0tfVE9LRU4vKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2ludGVncmF0aW9uIHJlc291cmNlIEFybicsICgpID0+IHtcblxuICAgIGxldCBzZXJ2aWNlOiBzdHJpbmc7XG4gICAgbGV0IGFwaTogc3RyaW5nO1xuICAgIGxldCBzdGFjazogY2RrLlN0YWNrO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgc2VydmljZSA9ICdsYW1iZGEnO1xuICAgICAgYXBpID0gJ2ludm9rZSc7XG4gICAgICBzdGFjayA9IG5ldyBjZGsuU3RhY2soKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2dldCByZXNvdXJjZUFybiBmb3IgYSByZXF1ZXN0L3Jlc3BvbnNlIGludGVncmF0aW9uIHBhdHRlcm4nLCAoKSA9PiB7XG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCByZXNvdXJjZUFybiA9IGludGVncmF0aW9uUmVzb3VyY2VBcm4oc2VydmljZSwgYXBpLCBJbnRlZ3JhdGlvblBhdHRlcm4uUkVRVUVTVF9SRVNQT05TRSk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKHJlc291cmNlQXJuKSkudG9FcXVhbCh7XG4gICAgICAgICdGbjo6Sm9pbic6IFtcbiAgICAgICAgICAnJyxcbiAgICAgICAgICBbXG4gICAgICAgICAgICAnYXJuOicsXG4gICAgICAgICAgICB7IFJlZjogJ0FXUzo6UGFydGl0aW9uJyB9LFxuICAgICAgICAgICAgJzpzdGF0ZXM6OjpsYW1iZGE6aW52b2tlJyxcbiAgICAgICAgICBdLFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZXQgcmVzb3VyY2VBcm4gZm9yIGEgcnVuIGpvYiBpbnRlZ3JhdGlvbiBwYXR0ZXJuJywgKCkgPT4ge1xuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgcmVzb3VyY2VBcm4gPSBpbnRlZ3JhdGlvblJlc291cmNlQXJuKHNlcnZpY2UsIGFwaSwgSW50ZWdyYXRpb25QYXR0ZXJuLlJVTl9KT0IpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShyZXNvdXJjZUFybikpLnRvRXF1YWwoe1xuICAgICAgICAnRm46OkpvaW4nOiBbXG4gICAgICAgICAgJycsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ2FybjonLFxuICAgICAgICAgICAgeyBSZWY6ICdBV1M6OlBhcnRpdGlvbicgfSxcbiAgICAgICAgICAgICc6c3RhdGVzOjo6bGFtYmRhOmludm9rZS5zeW5jJyxcbiAgICAgICAgICBdLFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZXQgcmVzb3VyY2VBcm4gZm9yIGEgd2FpdCBmb3IgdGFzayB0b2tlbiBpbnRlZ3JhdGlvbiBwYXR0ZXJuJywgKCkgPT4ge1xuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgcmVzb3VyY2VBcm4gPSBpbnRlZ3JhdGlvblJlc291cmNlQXJuKHNlcnZpY2UsIGFwaSwgSW50ZWdyYXRpb25QYXR0ZXJuLldBSVRfRk9SX1RBU0tfVE9LRU4pO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShyZXNvdXJjZUFybikpLnRvRXF1YWwoe1xuICAgICAgICAnRm46OkpvaW4nOiBbXG4gICAgICAgICAgJycsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ2FybjonLFxuICAgICAgICAgICAgeyBSZWY6ICdBV1M6OlBhcnRpdGlvbicgfSxcbiAgICAgICAgICAgICc6c3RhdGVzOjo6bGFtYmRhOmludm9rZS53YWl0Rm9yVGFza1Rva2VuJyxcbiAgICAgICAgICBdLFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdmYWlscyB3aGVuIHNlcnZpY2Ugb3IgYXBpIGlzIG5vdCBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBpbnRlZ3JhdGlvblJlc291cmNlQXJuKHNlcnZpY2UsICcnLCBJbnRlZ3JhdGlvblBhdHRlcm4uUlVOX0pPQik7XG4gICAgICB9KS50b1Rocm93KC9Cb3RoICdzZXJ2aWNlJyBhbmQgJ2FwaScgbXVzdCBiZSBwcm92aWRlZCB0byBidWlsZCB0aGUgcmVzb3VyY2UgQVJOLi8pO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBpbnRlZ3JhdGlvblJlc291cmNlQXJuKCcnLCBhcGksIEludGVncmF0aW9uUGF0dGVybi5SVU5fSk9CKTtcbiAgICAgIH0pLnRvVGhyb3coL0JvdGggJ3NlcnZpY2UnIGFuZCAnYXBpJyBtdXN0IGJlIHByb3ZpZGVkIHRvIGJ1aWxkIHRoZSByZXNvdXJjZSBBUk4uLyk7XG4gICAgfSk7XG4gIH0pO1xuXG59KTsiXX0=