"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("../../core");
const stepfunctions = require("../lib");
describe('Map State', () => {
    test('State Machine With Map State', () => {
        // GIVEN
        const stack = new cdk.Stack();
        // WHEN
        const map = new stepfunctions.Map(stack, 'Map State', {
            maxConcurrency: 1,
            itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
            parameters: {
                foo: 'foo',
                bar: stepfunctions.JsonPath.stringAt('$.bar'),
            },
        });
        map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
        // THEN
        expect(render(map)).toStrictEqual({
            StartAt: 'Map State',
            States: {
                'Map State': {
                    Type: 'Map',
                    End: true,
                    Parameters: {
                        'foo': 'foo',
                        'bar.$': '$.bar',
                    },
                    Iterator: {
                        StartAt: 'Pass State',
                        States: {
                            'Pass State': {
                                Type: 'Pass',
                                End: true,
                            },
                        },
                    },
                    ItemsPath: '$.inputForMap',
                    MaxConcurrency: 1,
                },
            },
        });
    }),
        test('State Machine With Map State and ResultSelector', () => {
            // GIVEN
            const stack = new cdk.Stack();
            // WHEN
            const map = new stepfunctions.Map(stack, 'Map State', {
                maxConcurrency: 1,
                itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                resultSelector: {
                    buz: 'buz',
                    baz: stepfunctions.JsonPath.stringAt('$.baz'),
                },
            });
            map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
            // THEN
            expect(render(map)).toStrictEqual({
                StartAt: 'Map State',
                States: {
                    'Map State': {
                        Type: 'Map',
                        End: true,
                        Iterator: {
                            StartAt: 'Pass State',
                            States: {
                                'Pass State': {
                                    Type: 'Pass',
                                    End: true,
                                },
                            },
                        },
                        ItemsPath: '$.inputForMap',
                        MaxConcurrency: 1,
                        ResultSelector: {
                            'buz': 'buz',
                            'baz.$': '$.baz',
                        },
                    },
                },
            });
        }),
        test('synth is successful', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: 1,
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
                return map;
            });
            app.synth();
        }),
        test('fails in synthesis if iterator is missing', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: 1,
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                return map;
            });
            expect(() => app.synth()).toThrow(/Map state must have a non-empty iterator/);
        }),
        test('fails in synthesis when maxConcurrency is a float', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: 1.2,
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
                return map;
            });
            expect(() => app.synth()).toThrow(/maxConcurrency has to be a positive integer/);
        }),
        test('fails in synthesis when maxConcurrency is a negative integer', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: -1,
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
                return map;
            });
            expect(() => app.synth()).toThrow(/maxConcurrency has to be a positive integer/);
        }),
        test('fails in synthesis when maxConcurrency is too big to be an integer', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: Number.MAX_VALUE,
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
                return map;
            });
            expect(() => app.synth()).toThrow(/maxConcurrency has to be a positive integer/);
        }),
        test('does not fail synthesis when maxConcurrency is a jsonPath', () => {
            const app = createAppWithMap((stack) => {
                const map = new stepfunctions.Map(stack, 'Map State', {
                    maxConcurrency: stepfunctions.JsonPath.numberAt('$.maxConcurrency'),
                    itemsPath: stepfunctions.JsonPath.stringAt('$.inputForMap'),
                });
                map.iterator(new stepfunctions.Pass(stack, 'Pass State'));
                return map;
            });
            expect(() => app.synth()).not.toThrow();
        });
    test('isPositiveInteger is false with negative number', () => {
        expect(stepfunctions.isPositiveInteger(-1)).toEqual(false);
    }),
        test('isPositiveInteger is false with decimal number', () => {
            expect(stepfunctions.isPositiveInteger(1.2)).toEqual(false);
        }),
        test('isPositiveInteger is false with a value greater than safe integer', () => {
            const valueToTest = Number.MAX_SAFE_INTEGER + 1;
            expect(stepfunctions.isPositiveInteger(valueToTest)).toEqual(false);
        }),
        test('isPositiveInteger is true with 0', () => {
            expect(stepfunctions.isPositiveInteger(0)).toEqual(true);
        }),
        test('isPositiveInteger is true with 10', () => {
            expect(stepfunctions.isPositiveInteger(10)).toEqual(true);
        }),
        test('isPositiveInteger is true with max integer value', () => {
            expect(stepfunctions.isPositiveInteger(Number.MAX_SAFE_INTEGER)).toEqual(true);
        });
});
function render(sm) {
    return new cdk.Stack().resolve(new stepfunctions.StateGraph(sm.startState, 'Test Graph').toGraphJson());
}
function createAppWithMap(mapFactory) {
    const app = new cdk.App();
    const stack = new cdk.Stack(app, 'my-stack');
    const map = mapFactory(stack);
    new stepfunctions.StateGraph(map, 'Test Graph');
    return app;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtYXAudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFFeEMsUUFBUSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUU7SUFDekIsSUFBSSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtRQUN4QyxRQUFRO1FBQ1IsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFOUIsT0FBTztRQUNQLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFO1lBQ3BELGNBQWMsRUFBRSxDQUFDO1lBQ2pCLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7WUFDM0QsVUFBVSxFQUFFO2dCQUNWLEdBQUcsRUFBRSxLQUFLO2dCQUNWLEdBQUcsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7YUFDOUM7U0FDRixDQUFDLENBQUM7UUFDSCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUUxRCxPQUFPO1FBQ1AsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztZQUNoQyxPQUFPLEVBQUUsV0FBVztZQUNwQixNQUFNLEVBQUU7Z0JBQ04sV0FBVyxFQUFFO29CQUNYLElBQUksRUFBRSxLQUFLO29CQUNYLEdBQUcsRUFBRSxJQUFJO29CQUNULFVBQVUsRUFBRTt3QkFDVixLQUFLLEVBQUUsS0FBSzt3QkFDWixPQUFPLEVBQUUsT0FBTztxQkFDakI7b0JBQ0QsUUFBUSxFQUFFO3dCQUNSLE9BQU8sRUFBRSxZQUFZO3dCQUNyQixNQUFNLEVBQUU7NEJBQ04sWUFBWSxFQUFFO2dDQUNaLElBQUksRUFBRSxNQUFNO2dDQUNaLEdBQUcsRUFBRSxJQUFJOzZCQUNWO3lCQUNGO3FCQUNGO29CQUNELFNBQVMsRUFBRSxlQUFlO29CQUMxQixjQUFjLEVBQUUsQ0FBQztpQkFDbEI7YUFDRjtTQUNGLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxpREFBaUQsRUFBRSxHQUFHLEVBQUU7WUFDM0QsUUFBUTtZQUNSLE1BQU0sS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRTlCLE9BQU87WUFDUCxNQUFNLEdBQUcsR0FBRyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRTtnQkFDcEQsY0FBYyxFQUFFLENBQUM7Z0JBQ2pCLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7Z0JBQzNELGNBQWMsRUFBRTtvQkFDZCxHQUFHLEVBQUUsS0FBSztvQkFDVixHQUFHLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO2lCQUM5QzthQUNGLENBQUMsQ0FBQztZQUNILEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBRTFELE9BQU87WUFDUCxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDO2dCQUNoQyxPQUFPLEVBQUUsV0FBVztnQkFDcEIsTUFBTSxFQUFFO29CQUNOLFdBQVcsRUFBRTt3QkFDWCxJQUFJLEVBQUUsS0FBSzt3QkFDWCxHQUFHLEVBQUUsSUFBSTt3QkFDVCxRQUFRLEVBQUU7NEJBQ1IsT0FBTyxFQUFFLFlBQVk7NEJBQ3JCLE1BQU0sRUFBRTtnQ0FDTixZQUFZLEVBQUU7b0NBQ1osSUFBSSxFQUFFLE1BQU07b0NBQ1osR0FBRyxFQUFFLElBQUk7aUNBQ1Y7NkJBQ0Y7eUJBQ0Y7d0JBQ0QsU0FBUyxFQUFFLGVBQWU7d0JBQzFCLGNBQWMsRUFBRSxDQUFDO3dCQUNqQixjQUFjLEVBQUU7NEJBQ2QsS0FBSyxFQUFFLEtBQUs7NEJBQ1osT0FBTyxFQUFFLE9BQU87eUJBQ2pCO3FCQUNGO2lCQUNGO2FBQ0YsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO1FBRUYsSUFBSSxDQUFDLHFCQUFxQixFQUFFLEdBQUcsRUFBRTtZQUMvQixNQUFNLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUNyQyxNQUFNLEdBQUcsR0FBRyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRTtvQkFDcEQsY0FBYyxFQUFFLENBQUM7b0JBQ2pCLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7aUJBQzVELENBQUMsQ0FBQztnQkFDSCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFDMUQsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDLENBQUMsQ0FBQztZQUVILEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNkLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQywyQ0FBMkMsRUFBRSxHQUFHLEVBQUU7WUFDckQsTUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDckMsTUFBTSxHQUFHLEdBQUcsSUFBSSxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7b0JBQ3BELGNBQWMsRUFBRSxDQUFDO29CQUNqQixTQUFTLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDO2lCQUM1RCxDQUFDLENBQUM7Z0JBRUgsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsMENBQTBDLENBQUMsQ0FBQztRQUNoRixDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsbURBQW1ELEVBQUUsR0FBRyxFQUFFO1lBQzdELE1BQU0sR0FBRyxHQUFHLGdCQUFnQixDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3JDLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFO29CQUNwRCxjQUFjLEVBQUUsR0FBRztvQkFDbkIsU0FBUyxFQUFFLGFBQWEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQztpQkFDNUQsQ0FBQyxDQUFDO2dCQUNILEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUUxRCxPQUFPLEdBQUcsQ0FBQztZQUNiLENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1FBQ25GLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyw4REFBOEQsRUFBRSxHQUFHLEVBQUU7WUFDeEUsTUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDckMsTUFBTSxHQUFHLEdBQUcsSUFBSSxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7b0JBQ3BELGNBQWMsRUFBRSxDQUFDLENBQUM7b0JBQ2xCLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7aUJBQzVELENBQUMsQ0FBQztnQkFDSCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFMUQsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsNkNBQTZDLENBQUMsQ0FBQztRQUNuRixDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsb0VBQW9FLEVBQUUsR0FBRyxFQUFFO1lBQzlFLE1BQU0sR0FBRyxHQUFHLGdCQUFnQixDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3JDLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFO29CQUNwRCxjQUFjLEVBQUUsTUFBTSxDQUFDLFNBQVM7b0JBQ2hDLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7aUJBQzVELENBQUMsQ0FBQztnQkFDSCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFMUQsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsNkNBQTZDLENBQUMsQ0FBQztRQUNuRixDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsMkRBQTJELEVBQUUsR0FBRyxFQUFFO1lBQ3JFLE1BQU0sR0FBRyxHQUFHLGdCQUFnQixDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3JDLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFO29CQUNwRCxjQUFjLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUM7b0JBQ25FLFNBQVMsRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7aUJBQzVELENBQUMsQ0FBQztnQkFDSCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFMUQsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsaURBQWlELEVBQUUsR0FBRyxFQUFFO1FBQzNELE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3RCxDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsZ0RBQWdELEVBQUUsR0FBRyxFQUFFO1lBQzFELE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFDO1FBRUYsSUFBSSxDQUFDLG1FQUFtRSxFQUFFLEdBQUcsRUFBRTtZQUM3RSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEUsQ0FBQyxDQUFDO1FBRUYsSUFBSSxDQUFDLGtDQUFrQyxFQUFFLEdBQUcsRUFBRTtZQUM1QyxNQUFNLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNELENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxtQ0FBbUMsRUFBRSxHQUFHLEVBQUU7WUFDN0MsTUFBTSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsa0RBQWtELEVBQUUsR0FBRyxFQUFFO1lBQzVELE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakYsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILFNBQVMsTUFBTSxDQUFDLEVBQTRCO0lBQzFDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksYUFBYSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDMUcsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsVUFBbUQ7SUFDM0UsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDMUIsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUM3QyxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUIsSUFBSSxhQUFhLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNoRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZGsgZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgKiBhcyBzdGVwZnVuY3Rpb25zIGZyb20gJy4uL2xpYic7XG5cbmRlc2NyaWJlKCdNYXAgU3RhdGUnLCAoKSA9PiB7XG4gIHRlc3QoJ1N0YXRlIE1hY2hpbmUgV2l0aCBNYXAgU3RhdGUnLCAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBjZGsuU3RhY2soKTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBtYXAgPSBuZXcgc3RlcGZ1bmN0aW9ucy5NYXAoc3RhY2ssICdNYXAgU3RhdGUnLCB7XG4gICAgICBtYXhDb25jdXJyZW5jeTogMSxcbiAgICAgIGl0ZW1zUGF0aDogc3RlcGZ1bmN0aW9ucy5Kc29uUGF0aC5zdHJpbmdBdCgnJC5pbnB1dEZvck1hcCcpLFxuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICBmb286ICdmb28nLFxuICAgICAgICBiYXI6IHN0ZXBmdW5jdGlvbnMuSnNvblBhdGguc3RyaW5nQXQoJyQuYmFyJyksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIG1hcC5pdGVyYXRvcihuZXcgc3RlcGZ1bmN0aW9ucy5QYXNzKHN0YWNrLCAnUGFzcyBTdGF0ZScpKTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3QocmVuZGVyKG1hcCkpLnRvU3RyaWN0RXF1YWwoe1xuICAgICAgU3RhcnRBdDogJ01hcCBTdGF0ZScsXG4gICAgICBTdGF0ZXM6IHtcbiAgICAgICAgJ01hcCBTdGF0ZSc6IHtcbiAgICAgICAgICBUeXBlOiAnTWFwJyxcbiAgICAgICAgICBFbmQ6IHRydWUsXG4gICAgICAgICAgUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgJ2Zvbyc6ICdmb28nLFxuICAgICAgICAgICAgJ2Jhci4kJzogJyQuYmFyJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEl0ZXJhdG9yOiB7XG4gICAgICAgICAgICBTdGFydEF0OiAnUGFzcyBTdGF0ZScsXG4gICAgICAgICAgICBTdGF0ZXM6IHtcbiAgICAgICAgICAgICAgJ1Bhc3MgU3RhdGUnOiB7XG4gICAgICAgICAgICAgICAgVHlwZTogJ1Bhc3MnLFxuICAgICAgICAgICAgICAgIEVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBJdGVtc1BhdGg6ICckLmlucHV0Rm9yTWFwJyxcbiAgICAgICAgICBNYXhDb25jdXJyZW5jeTogMSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pLFxuXG4gIHRlc3QoJ1N0YXRlIE1hY2hpbmUgV2l0aCBNYXAgU3RhdGUgYW5kIFJlc3VsdFNlbGVjdG9yJywgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgY2RrLlN0YWNrKCk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgbWFwID0gbmV3IHN0ZXBmdW5jdGlvbnMuTWFwKHN0YWNrLCAnTWFwIFN0YXRlJywge1xuICAgICAgbWF4Q29uY3VycmVuY3k6IDEsXG4gICAgICBpdGVtc1BhdGg6IHN0ZXBmdW5jdGlvbnMuSnNvblBhdGguc3RyaW5nQXQoJyQuaW5wdXRGb3JNYXAnKSxcbiAgICAgIHJlc3VsdFNlbGVjdG9yOiB7XG4gICAgICAgIGJ1ejogJ2J1eicsXG4gICAgICAgIGJhejogc3RlcGZ1bmN0aW9ucy5Kc29uUGF0aC5zdHJpbmdBdCgnJC5iYXonKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgbWFwLml0ZXJhdG9yKG5ldyBzdGVwZnVuY3Rpb25zLlBhc3Moc3RhY2ssICdQYXNzIFN0YXRlJykpO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChyZW5kZXIobWFwKSkudG9TdHJpY3RFcXVhbCh7XG4gICAgICBTdGFydEF0OiAnTWFwIFN0YXRlJyxcbiAgICAgIFN0YXRlczoge1xuICAgICAgICAnTWFwIFN0YXRlJzoge1xuICAgICAgICAgIFR5cGU6ICdNYXAnLFxuICAgICAgICAgIEVuZDogdHJ1ZSxcbiAgICAgICAgICBJdGVyYXRvcjoge1xuICAgICAgICAgICAgU3RhcnRBdDogJ1Bhc3MgU3RhdGUnLFxuICAgICAgICAgICAgU3RhdGVzOiB7XG4gICAgICAgICAgICAgICdQYXNzIFN0YXRlJzoge1xuICAgICAgICAgICAgICAgIFR5cGU6ICdQYXNzJyxcbiAgICAgICAgICAgICAgICBFbmQ6IHRydWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgSXRlbXNQYXRoOiAnJC5pbnB1dEZvck1hcCcsXG4gICAgICAgICAgTWF4Q29uY3VycmVuY3k6IDEsXG4gICAgICAgICAgUmVzdWx0U2VsZWN0b3I6IHtcbiAgICAgICAgICAgICdidXonOiAnYnV6JyxcbiAgICAgICAgICAgICdiYXouJCc6ICckLmJheicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pLFxuXG4gIHRlc3QoJ3N5bnRoIGlzIHN1Y2Nlc3NmdWwnLCAoKSA9PiB7XG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwV2l0aE1hcCgoc3RhY2spID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBzdGVwZnVuY3Rpb25zLk1hcChzdGFjaywgJ01hcCBTdGF0ZScsIHtcbiAgICAgICAgbWF4Q29uY3VycmVuY3k6IDEsXG4gICAgICAgIGl0ZW1zUGF0aDogc3RlcGZ1bmN0aW9ucy5Kc29uUGF0aC5zdHJpbmdBdCgnJC5pbnB1dEZvck1hcCcpLFxuICAgICAgfSk7XG4gICAgICBtYXAuaXRlcmF0b3IobmV3IHN0ZXBmdW5jdGlvbnMuUGFzcyhzdGFjaywgJ1Bhc3MgU3RhdGUnKSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuXG4gICAgYXBwLnN5bnRoKCk7XG4gIH0pLFxuXG4gIHRlc3QoJ2ZhaWxzIGluIHN5bnRoZXNpcyBpZiBpdGVyYXRvciBpcyBtaXNzaW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcFdpdGhNYXAoKHN0YWNrKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgc3RlcGZ1bmN0aW9ucy5NYXAoc3RhY2ssICdNYXAgU3RhdGUnLCB7XG4gICAgICAgIG1heENvbmN1cnJlbmN5OiAxLFxuICAgICAgICBpdGVtc1BhdGg6IHN0ZXBmdW5jdGlvbnMuSnNvblBhdGguc3RyaW5nQXQoJyQuaW5wdXRGb3JNYXAnKSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuXG4gICAgZXhwZWN0KCgpID0+IGFwcC5zeW50aCgpKS50b1Rocm93KC9NYXAgc3RhdGUgbXVzdCBoYXZlIGEgbm9uLWVtcHR5IGl0ZXJhdG9yLyk7XG4gIH0pLFxuXG4gIHRlc3QoJ2ZhaWxzIGluIHN5bnRoZXNpcyB3aGVuIG1heENvbmN1cnJlbmN5IGlzIGEgZmxvYXQnLCAoKSA9PiB7XG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwV2l0aE1hcCgoc3RhY2spID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBzdGVwZnVuY3Rpb25zLk1hcChzdGFjaywgJ01hcCBTdGF0ZScsIHtcbiAgICAgICAgbWF4Q29uY3VycmVuY3k6IDEuMixcbiAgICAgICAgaXRlbXNQYXRoOiBzdGVwZnVuY3Rpb25zLkpzb25QYXRoLnN0cmluZ0F0KCckLmlucHV0Rm9yTWFwJyksXG4gICAgICB9KTtcbiAgICAgIG1hcC5pdGVyYXRvcihuZXcgc3RlcGZ1bmN0aW9ucy5QYXNzKHN0YWNrLCAnUGFzcyBTdGF0ZScpKTtcblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcblxuICAgIGV4cGVjdCgoKSA9PiBhcHAuc3ludGgoKSkudG9UaHJvdygvbWF4Q29uY3VycmVuY3kgaGFzIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlci8pO1xuICB9KSxcblxuICB0ZXN0KCdmYWlscyBpbiBzeW50aGVzaXMgd2hlbiBtYXhDb25jdXJyZW5jeSBpcyBhIG5lZ2F0aXZlIGludGVnZXInLCAoKSA9PiB7XG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwV2l0aE1hcCgoc3RhY2spID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBzdGVwZnVuY3Rpb25zLk1hcChzdGFjaywgJ01hcCBTdGF0ZScsIHtcbiAgICAgICAgbWF4Q29uY3VycmVuY3k6IC0xLFxuICAgICAgICBpdGVtc1BhdGg6IHN0ZXBmdW5jdGlvbnMuSnNvblBhdGguc3RyaW5nQXQoJyQuaW5wdXRGb3JNYXAnKSxcbiAgICAgIH0pO1xuICAgICAgbWFwLml0ZXJhdG9yKG5ldyBzdGVwZnVuY3Rpb25zLlBhc3Moc3RhY2ssICdQYXNzIFN0YXRlJykpO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuXG4gICAgZXhwZWN0KCgpID0+IGFwcC5zeW50aCgpKS50b1Rocm93KC9tYXhDb25jdXJyZW5jeSBoYXMgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLyk7XG4gIH0pLFxuXG4gIHRlc3QoJ2ZhaWxzIGluIHN5bnRoZXNpcyB3aGVuIG1heENvbmN1cnJlbmN5IGlzIHRvbyBiaWcgdG8gYmUgYW4gaW50ZWdlcicsICgpID0+IHtcbiAgICBjb25zdCBhcHAgPSBjcmVhdGVBcHBXaXRoTWFwKChzdGFjaykgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IHN0ZXBmdW5jdGlvbnMuTWFwKHN0YWNrLCAnTWFwIFN0YXRlJywge1xuICAgICAgICBtYXhDb25jdXJyZW5jeTogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgaXRlbXNQYXRoOiBzdGVwZnVuY3Rpb25zLkpzb25QYXRoLnN0cmluZ0F0KCckLmlucHV0Rm9yTWFwJyksXG4gICAgICB9KTtcbiAgICAgIG1hcC5pdGVyYXRvcihuZXcgc3RlcGZ1bmN0aW9ucy5QYXNzKHN0YWNrLCAnUGFzcyBTdGF0ZScpKTtcblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcblxuICAgIGV4cGVjdCgoKSA9PiBhcHAuc3ludGgoKSkudG9UaHJvdygvbWF4Q29uY3VycmVuY3kgaGFzIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlci8pO1xuICB9KSxcblxuICB0ZXN0KCdkb2VzIG5vdCBmYWlsIHN5bnRoZXNpcyB3aGVuIG1heENvbmN1cnJlbmN5IGlzIGEganNvblBhdGgnLCAoKSA9PiB7XG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwV2l0aE1hcCgoc3RhY2spID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBzdGVwZnVuY3Rpb25zLk1hcChzdGFjaywgJ01hcCBTdGF0ZScsIHtcbiAgICAgICAgbWF4Q29uY3VycmVuY3k6IHN0ZXBmdW5jdGlvbnMuSnNvblBhdGgubnVtYmVyQXQoJyQubWF4Q29uY3VycmVuY3knKSxcbiAgICAgICAgaXRlbXNQYXRoOiBzdGVwZnVuY3Rpb25zLkpzb25QYXRoLnN0cmluZ0F0KCckLmlucHV0Rm9yTWFwJyksXG4gICAgICB9KTtcbiAgICAgIG1hcC5pdGVyYXRvcihuZXcgc3RlcGZ1bmN0aW9ucy5QYXNzKHN0YWNrLCAnUGFzcyBTdGF0ZScpKTtcblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcblxuICAgIGV4cGVjdCgoKSA9PiBhcHAuc3ludGgoKSkubm90LnRvVGhyb3coKTtcbiAgfSk7XG5cbiAgdGVzdCgnaXNQb3NpdGl2ZUludGVnZXIgaXMgZmFsc2Ugd2l0aCBuZWdhdGl2ZSBudW1iZXInLCAoKSA9PiB7XG4gICAgZXhwZWN0KHN0ZXBmdW5jdGlvbnMuaXNQb3NpdGl2ZUludGVnZXIoLTEpKS50b0VxdWFsKGZhbHNlKTtcbiAgfSksXG5cbiAgdGVzdCgnaXNQb3NpdGl2ZUludGVnZXIgaXMgZmFsc2Ugd2l0aCBkZWNpbWFsIG51bWJlcicsICgpID0+IHtcbiAgICBleHBlY3Qoc3RlcGZ1bmN0aW9ucy5pc1Bvc2l0aXZlSW50ZWdlcigxLjIpKS50b0VxdWFsKGZhbHNlKTtcbiAgfSksXG5cbiAgdGVzdCgnaXNQb3NpdGl2ZUludGVnZXIgaXMgZmFsc2Ugd2l0aCBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBzYWZlIGludGVnZXInLCAoKSA9PiB7XG4gICAgY29uc3QgdmFsdWVUb1Rlc3QgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiArIDE7XG4gICAgZXhwZWN0KHN0ZXBmdW5jdGlvbnMuaXNQb3NpdGl2ZUludGVnZXIodmFsdWVUb1Rlc3QpKS50b0VxdWFsKGZhbHNlKTtcbiAgfSksXG5cbiAgdGVzdCgnaXNQb3NpdGl2ZUludGVnZXIgaXMgdHJ1ZSB3aXRoIDAnLCAoKSA9PiB7XG4gICAgZXhwZWN0KHN0ZXBmdW5jdGlvbnMuaXNQb3NpdGl2ZUludGVnZXIoMCkpLnRvRXF1YWwodHJ1ZSk7XG4gIH0pLFxuXG4gIHRlc3QoJ2lzUG9zaXRpdmVJbnRlZ2VyIGlzIHRydWUgd2l0aCAxMCcsICgpID0+IHtcbiAgICBleHBlY3Qoc3RlcGZ1bmN0aW9ucy5pc1Bvc2l0aXZlSW50ZWdlcigxMCkpLnRvRXF1YWwodHJ1ZSk7XG4gIH0pLFxuXG4gIHRlc3QoJ2lzUG9zaXRpdmVJbnRlZ2VyIGlzIHRydWUgd2l0aCBtYXggaW50ZWdlciB2YWx1ZScsICgpID0+IHtcbiAgICBleHBlY3Qoc3RlcGZ1bmN0aW9ucy5pc1Bvc2l0aXZlSW50ZWdlcihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpLnRvRXF1YWwodHJ1ZSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHJlbmRlcihzbTogc3RlcGZ1bmN0aW9ucy5JQ2hhaW5hYmxlKSB7XG4gIHJldHVybiBuZXcgY2RrLlN0YWNrKCkucmVzb2x2ZShuZXcgc3RlcGZ1bmN0aW9ucy5TdGF0ZUdyYXBoKHNtLnN0YXJ0U3RhdGUsICdUZXN0IEdyYXBoJykudG9HcmFwaEpzb24oKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcFdpdGhNYXAobWFwRmFjdG9yeTogKHN0YWNrOiBjZGsuU3RhY2spID0+IHN0ZXBmdW5jdGlvbnMuTWFwKSB7XG4gIGNvbnN0IGFwcCA9IG5ldyBjZGsuQXBwKCk7XG4gIGNvbnN0IHN0YWNrID0gbmV3IGNkay5TdGFjayhhcHAsICdteS1zdGFjaycpO1xuICBjb25zdCBtYXAgPSBtYXBGYWN0b3J5KHN0YWNrKTtcbiAgbmV3IHN0ZXBmdW5jdGlvbnMuU3RhdGVHcmFwaChtYXAsICdUZXN0IEdyYXBoJyk7XG4gIHJldHVybiBhcHA7XG59XG4iXX0=