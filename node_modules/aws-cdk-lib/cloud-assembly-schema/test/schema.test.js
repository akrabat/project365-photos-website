"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const update_schema_1 = require("../scripts/update-schema");
test.skip('if this test fails, run "yarn update-schema"', () => {
    // when we compare schemas we ignore changes the
    // description that is generated from the ts docstrings.
    const docStringFields = [
        'description',
    ];
    for (const schemaName of update_schema_1.SCHEMAS) {
        const expected = removeStringKeys((0, update_schema_1.generateSchema)(schemaName, false), docStringFields);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const actual = removeStringKeys(require(`../schema/${schemaName}.schema.json`), docStringFields);
        try {
            expect(actual).toEqual(expected);
        }
        catch (err) {
            // I couldn't for the life of me figure out how to provide additional error message
            // to jest...any ideas?
            err.message = `Whoops, Looks like the schema has changed. Did you forget to run 'yarn update-schema'?\n\n${err.message}`;
            throw err;
        }
    }
});
function removeStringKeys(obj, keys) {
    function _recurse(o) {
        for (const prop in o) {
            if (keys.includes(prop) && typeof o[prop] === 'string') {
                delete o[prop];
            }
            else if (typeof o[prop] === 'object') {
                _recurse(o[prop]);
            }
        }
    }
    const cloned = clone(obj);
    _recurse(cloned);
    return cloned;
}
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzY2hlbWEudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDREQUFtRTtBQUVuRSxJQUFJLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxFQUFFLEdBQUcsRUFBRTtJQUU3RCxnREFBZ0Q7SUFDaEQsd0RBQXdEO0lBQ3hELE1BQU0sZUFBZSxHQUFHO1FBQ3RCLGFBQWE7S0FDZCxDQUFDO0lBRUYsS0FBSyxNQUFNLFVBQVUsSUFBSSx1QkFBTyxFQUFFO1FBQ2hDLE1BQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLElBQUEsOEJBQWMsRUFBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFdEYsaUVBQWlFO1FBQ2pFLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxhQUFhLFVBQVUsY0FBYyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFakcsSUFBSTtZQUNGLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEdBQVEsRUFBRTtZQUNqQixtRkFBbUY7WUFDbkYsdUJBQXVCO1lBQ3ZCLEdBQUcsQ0FBQyxPQUFPLEdBQUcsNkZBQTZGLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6SCxNQUFNLEdBQUcsQ0FBQztTQUNYO0tBQ0Y7QUFFSCxDQUFDLENBQUMsQ0FBQztBQUVILFNBQVMsZ0JBQWdCLENBQUMsR0FBUSxFQUFFLElBQWM7SUFFaEQsU0FBUyxRQUFRLENBQUMsQ0FBTTtRQUN0QixLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsRUFBRTtZQUNwQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUN0RCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoQjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLFFBQVEsRUFBRTtnQkFDdEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQ25CO1NBQ0Y7SUFDSCxDQUFDO0lBQ0QsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQixPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsU0FBUyxLQUFLLENBQUMsR0FBUTtJQUNyQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmF0ZVNjaGVtYSwgU0NIRU1BUyB9IGZyb20gJy4uL3NjcmlwdHMvdXBkYXRlLXNjaGVtYSc7XG5cbnRlc3Quc2tpcCgnaWYgdGhpcyB0ZXN0IGZhaWxzLCBydW4gXCJ5YXJuIHVwZGF0ZS1zY2hlbWFcIicsICgpID0+IHtcblxuICAvLyB3aGVuIHdlIGNvbXBhcmUgc2NoZW1hcyB3ZSBpZ25vcmUgY2hhbmdlcyB0aGVcbiAgLy8gZGVzY3JpcHRpb24gdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdHMgZG9jc3RyaW5ncy5cbiAgY29uc3QgZG9jU3RyaW5nRmllbGRzID0gW1xuICAgICdkZXNjcmlwdGlvbicsXG4gIF07XG5cbiAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIFNDSEVNQVMpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IHJlbW92ZVN0cmluZ0tleXMoZ2VuZXJhdGVTY2hlbWEoc2NoZW1hTmFtZSwgZmFsc2UpLCBkb2NTdHJpbmdGaWVsZHMpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjb25zdCBhY3R1YWwgPSByZW1vdmVTdHJpbmdLZXlzKHJlcXVpcmUoYC4uL3NjaGVtYS8ke3NjaGVtYU5hbWV9LnNjaGVtYS5qc29uYCksIGRvY1N0cmluZ0ZpZWxkcyk7XG5cbiAgICB0cnkge1xuICAgICAgZXhwZWN0KGFjdHVhbCkudG9FcXVhbChleHBlY3RlZCk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIC8vIEkgY291bGRuJ3QgZm9yIHRoZSBsaWZlIG9mIG1lIGZpZ3VyZSBvdXQgaG93IHRvIHByb3ZpZGUgYWRkaXRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAgICAvLyB0byBqZXN0Li4uYW55IGlkZWFzP1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgV2hvb3BzLCBMb29rcyBsaWtlIHRoZSBzY2hlbWEgaGFzIGNoYW5nZWQuIERpZCB5b3UgZm9yZ2V0IHRvIHJ1biAneWFybiB1cGRhdGUtc2NoZW1hJz9cXG5cXG4ke2Vyci5tZXNzYWdlfWA7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiByZW1vdmVTdHJpbmdLZXlzKG9iajogYW55LCBrZXlzOiBzdHJpbmdbXSkge1xuXG4gIGZ1bmN0aW9uIF9yZWN1cnNlKG86IGFueSkge1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBvKSB7XG4gICAgICBpZiAoa2V5cy5pbmNsdWRlcyhwcm9wKSAmJiB0eXBlb2Ygb1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGVsZXRlIG9bcHJvcF07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBfcmVjdXJzZShvW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY2xvbmVkID0gY2xvbmUob2JqKTtcbiAgX3JlY3Vyc2UoY2xvbmVkKTtcbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuZnVuY3Rpb24gY2xvbmUob2JqOiBhbnkpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4iXX0=