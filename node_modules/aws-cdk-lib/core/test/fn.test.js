"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fc = require("fast-check");
const _ = require("lodash");
const lib_1 = require("../lib");
const intrinsic_1 = require("../lib/private/intrinsic");
function asyncTest(cb) {
    return async () => {
        let error;
        try {
            await cb();
        }
        catch (e) {
            error = e;
        }
        finally {
            expect(() => {
                if (error) {
                    throw error;
                }
            }).not.toThrow();
        }
    };
}
const nonEmptyString = fc.string(1, 16);
const tokenish = fc.array(nonEmptyString, 2, 2).map(arr => ({ [arr[0]]: arr[1] }));
const anyValue = fc.oneof(nonEmptyString, tokenish);
describe('fn', () => {
    describe('eager resolution for non-tokens', () => {
        test('Fn.select', () => {
            expect(lib_1.Fn.select(2, ['hello', 'you', 'dude'])).toEqual('dude');
        });
        test('Fn.select does not short-circuit if there are tokens in the array', () => {
            const stack = new lib_1.Stack();
            expect(stack.resolve(lib_1.Fn.select(2, [
                lib_1.Fn.conditionIf('xyz', 'yep', lib_1.Aws.NO_VALUE).toString(),
                'you',
                'dude',
            ]))).toEqual({
                'Fn::Select': [2, [
                        { 'Fn::If': ['xyz', 'yep', { Ref: 'AWS::NoValue' }] },
                        'you',
                        'dude',
                    ]],
            });
        });
        test('Fn.split', () => {
            expect(lib_1.Fn.split(':', 'hello:world:yeah')).toEqual(['hello', 'world', 'yeah']);
        });
    });
    describe('FnParseDomainName', () => {
        test('parse domain name from resolved url', () => {
            expect(lib_1.Fn.parseDomainName('https://test.com/')).toEqual('test.com');
        });
        test('parse domain name on token', () => {
            const stack = new lib_1.Stack();
            const url = lib_1.Fn.join('//', [
                'https:',
                lib_1.Fn.join('/', [
                    'test.com',
                    'graphql',
                ]),
            ]);
            expect(lib_1.Fn.parseDomainName(stack.resolve(url))).toEqual('test.com');
        });
    });
    describe('FnJoin', () => {
        test('rejects empty list of arguments to join', () => {
            expect(() => lib_1.Fn.join('.', [])).toThrow();
        });
        test('collapse nested FnJoins even if they contain tokens', () => {
            const stack = new lib_1.Stack();
            const obj = lib_1.Fn.join('', [
                'a',
                lib_1.Fn.join('', [lib_1.Fn.getAtt('a', 'bc').toString(), 'c']),
                'd',
            ]);
            expect(stack.resolve(obj)).toEqual({
                'Fn::Join': ['',
                    [
                        'a',
                        { 'Fn::GetAtt': ['a', 'bc'] },
                        'cd',
                    ]],
            });
        });
        test('resolves to the value if only one value is joined', asyncTest(async () => {
            const stack = new lib_1.Stack();
            fc.assert(fc.property(fc.string(), anyValue, (delimiter, value) => _.isEqual(stack.resolve(lib_1.Fn.join(delimiter, [value])), value)), { verbose: true });
        }));
        test('pre-concatenates string literals', asyncTest(async () => {
            const stack = new lib_1.Stack();
            fc.assert(fc.property(fc.string(), fc.array(nonEmptyString, 1, 15), (delimiter, values) => stack.resolve(lib_1.Fn.join(delimiter, values)) === values.join(delimiter)), { verbose: true });
        }));
        test('pre-concatenates around tokens', asyncTest(async () => {
            const stack = new lib_1.Stack();
            fc.assert(fc.property(fc.string(), fc.array(nonEmptyString, 1, 3), tokenish, fc.array(nonEmptyString, 1, 3), (delimiter, prefix, obj, suffix) => _.isEqual(stack.resolve(lib_1.Fn.join(delimiter, [...prefix, stringToken(obj), ...suffix])), { 'Fn::Join': [delimiter, [prefix.join(delimiter), obj, suffix.join(delimiter)]] })), { verbose: true, seed: 1539874645005, path: '0:0:0:0:0:0:0:0:0' });
        }));
        test('flattens joins nested under joins with same delimiter', asyncTest(async () => {
            const stack = new lib_1.Stack();
            fc.assert(fc.property(fc.string(), fc.array(anyValue), fc.array(anyValue, 1, 3), fc.array(anyValue), (delimiter, prefix, nested, suffix) => 
            // Gonna test
            _.isEqual(stack.resolve(lib_1.Fn.join(delimiter, [...prefix, lib_1.Fn.join(delimiter, nested), ...suffix])), stack.resolve(lib_1.Fn.join(delimiter, [...prefix, ...nested, ...suffix])))), { verbose: true });
        }));
        test('does not flatten joins nested under joins with different delimiter', asyncTest(async () => {
            const stack = new lib_1.Stack();
            fc.assert(fc.property(fc.string(), fc.string(), fc.array(anyValue, 1, 3), fc.array(tokenish, 2, 3), fc.array(anyValue, 3), (delimiter1, delimiter2, prefix, nested, suffix) => {
                fc.pre(delimiter1 !== delimiter2);
                const join = lib_1.Fn.join(delimiter1, [...prefix, lib_1.Fn.join(delimiter2, stringListToken(nested)), ...suffix]);
                const resolved = stack.resolve(join);
                return resolved['Fn::Join'][1].find((e) => typeof e === 'object'
                    && ('Fn::Join' in e)
                    && e['Fn::Join'][0] === delimiter2) != null;
            }), { verbose: true });
        }));
        test('Fn::EachMemberIn', asyncTest(async () => {
            const stack = new lib_1.Stack();
            const eachMemberIn = lib_1.Fn.conditionEachMemberIn(lib_1.Fn.valueOfAll('AWS::EC2::Subnet::Id', 'VpcId'), lib_1.Fn.refAll('AWS::EC2::VPC::Id'));
            expect(stack.resolve(eachMemberIn)).toEqual({
                'Fn::EachMemberIn': [
                    { 'Fn::ValueOfAll': ['AWS::EC2::Subnet::Id', 'VpcId'] },
                    { 'Fn::RefAll': 'AWS::EC2::VPC::Id' },
                ],
            });
        }));
        test('cross-stack FnJoin elements are properly resolved', asyncTest(async () => {
            // GIVEN
            const app = new lib_1.App();
            const stack1 = new lib_1.Stack(app, 'Stack1');
            const stack2 = new lib_1.Stack(app, 'Stack2');
            // WHEN
            new lib_1.CfnOutput(stack2, 'Stack1Id', {
                value: lib_1.Fn.join(' = ', ['Stack1Id', stack1.stackId]),
            });
            // THEN
            const template = app.synth().getStackByName('Stack2').template;
            expect(template?.Outputs).toEqual({
                Stack1Id: {
                    Value: {
                        'Fn::Join': [' = ', [
                                'Stack1Id',
                                { 'Fn::ImportValue': 'Stack1:ExportsOutputRefAWSStackIdB2DD5BAA' },
                            ]],
                    },
                },
            });
        }));
    });
    describe('Ref', () => {
        test('returns a reference given a logical name', () => {
            const stack = new lib_1.Stack();
            expect(stack.resolve(lib_1.Fn.ref('hello'))).toEqual({
                Ref: 'hello',
            });
        });
    });
    test('nested Fn::Join with list token', () => {
        const stack = new lib_1.Stack();
        const inner = lib_1.Fn.join(',', lib_1.Token.asList({ NotReallyList: true }));
        const outer = lib_1.Fn.join(',', [inner, 'Foo']);
        expect(stack.resolve(outer)).toEqual({
            'Fn::Join': [
                ',',
                [
                    { 'Fn::Join': [',', { NotReallyList: true }] },
                    'Foo',
                ],
            ],
        });
    });
});
test('Fn.split with an unknown length resolves to simple {Fn::Split}', () => {
    const stack = new lib_1.Stack();
    const splittableToken = lib_1.Token.asString({ ThisIsASplittable: 'list' });
    const splitToken = lib_1.Fn.split(',', splittableToken);
    expect(stack.resolve(splitToken)).toEqual({ 'Fn::Split': [',', { ThisIsASplittable: 'list' }] });
});
test('Fn.split with an assumed length resolves to a list of {Fn::Select}s', () => {
    const stack = new lib_1.Stack();
    const splittableToken = lib_1.Token.asString({ ThisIsASplittable: 'list' });
    const splitToken = lib_1.Fn.split(',', splittableToken, 3);
    const splitValue = { 'Fn::Split': [',', { ThisIsASplittable: 'list' }] };
    expect(stack.resolve(splitToken)).toEqual([
        { 'Fn::Select': [0, splitValue] },
        { 'Fn::Select': [1, splitValue] },
        { 'Fn::Select': [2, splitValue] },
    ]);
});
test('Fn.importListValue produces lists of known length', () => {
    const stack = new lib_1.Stack();
    const splitToken = lib_1.Fn.importListValue('ExportName', 3);
    const splitValue = { 'Fn::Split': [',', { 'Fn::ImportValue': 'ExportName' }] };
    expect(stack.resolve(splitToken)).toEqual([
        { 'Fn::Select': [0, splitValue] },
        { 'Fn::Select': [1, splitValue] },
        { 'Fn::Select': [2, splitValue] },
    ]);
});
test('Fn.toJsonString', () => {
    const stack = new lib_1.Stack();
    const token = lib_1.Token.asAny({ key: 'value' });
    expect(stack.resolve(lib_1.Fn.toJsonString(token))).toEqual({ 'Fn::ToJsonString': { key: 'value' } });
    expect(stack.templateOptions.transforms).toEqual(expect.arrayContaining([
        'AWS::LanguageExtensions',
    ]));
});
test('Fn.toJsonString with resolved value', () => {
    expect(lib_1.Fn.toJsonString({ key: 'value' })).toEqual('{\"key\":\"value\"}');
});
test('Fn.len', () => {
    const stack = new lib_1.Stack();
    const token = lib_1.Fn.split('|', lib_1.Token.asString({ ThisIsASplittable: 'list' }));
    expect(stack.resolve(lib_1.Fn.len(token))).toEqual({
        'Fn::Length': {
            'Fn::Split': [
                '|',
                {
                    ThisIsASplittable: 'list',
                },
            ],
        },
    });
    expect(stack.templateOptions.transforms).toEqual(expect.arrayContaining([
        'AWS::LanguageExtensions',
    ]));
});
test('Fn.len with resolved value', () => {
    expect(lib_1.Fn.len(lib_1.Fn.split('|', 'a|b|c'))).toBe(3);
});
function stringListToken(o) {
    return lib_1.Token.asList(new intrinsic_1.Intrinsic(o));
}
function stringToken(o) {
    return lib_1.Token.asString(new intrinsic_1.Intrinsic(o));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm4udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZuLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLGdDQUErRDtBQUMvRCx3REFBcUQ7QUFFckQsU0FBUyxTQUFTLENBQUMsRUFBdUI7SUFDeEMsT0FBTyxLQUFLLElBQUksRUFBRTtRQUNoQixJQUFJLEtBQVUsQ0FBQztRQUNmLElBQUk7WUFDRixNQUFNLEVBQUUsRUFBRSxDQUFDO1NBQ1o7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLEtBQUssR0FBRyxDQUFDLENBQUM7U0FDWDtnQkFBUztZQUNSLE1BQU0sQ0FBQyxHQUFHLEVBQUU7Z0JBQ1YsSUFBSSxLQUFLLEVBQUU7b0JBQUUsTUFBTSxLQUFLLENBQUM7aUJBQUU7WUFDN0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2xCO0lBQ0gsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkYsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBTSxjQUFjLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFFekQsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7SUFDbEIsUUFBUSxDQUFDLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtRQUMvQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFB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QyxRQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxlQUFlLENBQUMsQ0FBTTtJQUM3QixPQUFPLFdBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxxQkFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUNELFNBQVMsV0FBVyxDQUFDLENBQU07SUFDekIsT0FBTyxXQUFLLENBQUMsUUFBUSxDQUFDLElBQUkscUJBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEFwcCwgQXdzLCBDZm5PdXRwdXQsIEZuLCBTdGFjaywgVG9rZW4gfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgSW50cmluc2ljIH0gZnJvbSAnLi4vbGliL3ByaXZhdGUvaW50cmluc2ljJztcblxuZnVuY3Rpb24gYXN5bmNUZXN0KGNiOiAoKSA9PiBQcm9taXNlPHZvaWQ+KTogKCkgPT4gdm9pZCB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGVycm9yOiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNiKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHsgdGhyb3cgZXJyb3I7IH1cbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBub25FbXB0eVN0cmluZyA9IGZjLnN0cmluZygxLCAxNik7XG5jb25zdCB0b2tlbmlzaCA9IGZjLmFycmF5KG5vbkVtcHR5U3RyaW5nLCAyLCAyKS5tYXAoYXJyID0+ICh7IFthcnJbMF1dOiBhcnJbMV0gfSkpO1xuY29uc3QgYW55VmFsdWUgPSBmYy5vbmVvZjxhbnk+KG5vbkVtcHR5U3RyaW5nLCB0b2tlbmlzaCk7XG5cbmRlc2NyaWJlKCdmbicsICgpID0+IHtcbiAgZGVzY3JpYmUoJ2VhZ2VyIHJlc29sdXRpb24gZm9yIG5vbi10b2tlbnMnLCAoKSA9PiB7XG4gICAgdGVzdCgnRm4uc2VsZWN0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KEZuLnNlbGVjdCgyLCBbJ2hlbGxvJywgJ3lvdScsICdkdWRlJ10pKS50b0VxdWFsKCdkdWRlJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdGbi5zZWxlY3QgZG9lcyBub3Qgc2hvcnQtY2lyY3VpdCBpZiB0aGVyZSBhcmUgdG9rZW5zIGluIHRoZSBhcnJheScsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKEZuLnNlbGVjdCgyLCBbXG4gICAgICAgIEZuLmNvbmRpdGlvbklmKCd4eXonLCAneWVwJywgQXdzLk5PX1ZBTFVFKS50b1N0cmluZygpLFxuICAgICAgICAneW91JyxcbiAgICAgICAgJ2R1ZGUnLFxuICAgICAgXSkpKS50b0VxdWFsKHtcbiAgICAgICAgJ0ZuOjpTZWxlY3QnOiBbMiwgW1xuICAgICAgICAgIHsgJ0ZuOjpJZic6IFsneHl6JywgJ3llcCcsIHsgUmVmOiAnQVdTOjpOb1ZhbHVlJyB9XSB9LFxuICAgICAgICAgICd5b3UnLFxuICAgICAgICAgICdkdWRlJyxcbiAgICAgICAgXV0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ0ZuLnNwbGl0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KEZuLnNwbGl0KCc6JywgJ2hlbGxvOndvcmxkOnllYWgnKSkudG9FcXVhbChbJ2hlbGxvJywgJ3dvcmxkJywgJ3llYWgnXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGblBhcnNlRG9tYWluTmFtZScsICgpID0+IHtcbiAgICB0ZXN0KCdwYXJzZSBkb21haW4gbmFtZSBmcm9tIHJlc29sdmVkIHVybCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChGbi5wYXJzZURvbWFpbk5hbWUoJ2h0dHBzOi8vdGVzdC5jb20vJykpLnRvRXF1YWwoJ3Rlc3QuY29tJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdwYXJzZSBkb21haW4gbmFtZSBvbiB0b2tlbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgICBjb25zdCB1cmwgPSBGbi5qb2luKCcvLycsIFtcbiAgICAgICAgJ2h0dHBzOicsXG4gICAgICAgIEZuLmpvaW4oJy8nLCBbXG4gICAgICAgICAgJ3Rlc3QuY29tJyxcbiAgICAgICAgICAnZ3JhcGhxbCcsXG4gICAgICAgIF0pLFxuICAgICAgXSk7XG4gICAgICBleHBlY3QoRm4ucGFyc2VEb21haW5OYW1lKHN0YWNrLnJlc29sdmUodXJsKSkpLnRvRXF1YWwoJ3Rlc3QuY29tJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGbkpvaW4nLCAoKSA9PiB7XG4gICAgdGVzdCgncmVqZWN0cyBlbXB0eSBsaXN0IG9mIGFyZ3VtZW50cyB0byBqb2luJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IEZuLmpvaW4oJy4nLCBbXSkpLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NvbGxhcHNlIG5lc3RlZCBGbkpvaW5zIGV2ZW4gaWYgdGhleSBjb250YWluIHRva2VucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICAgIGNvbnN0IG9iaiA9IEZuLmpvaW4oJycsIFtcbiAgICAgICAgJ2EnLFxuICAgICAgICBGbi5qb2luKCcnLCBbRm4uZ2V0QXR0KCdhJywgJ2JjJykudG9TdHJpbmcoKSwgJ2MnXSksXG4gICAgICAgICdkJyxcbiAgICAgIF0pO1xuXG4gICAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShvYmopKS50b0VxdWFsKHtcbiAgICAgICAgJ0ZuOjpKb2luJzogWycnLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIHsgJ0ZuOjpHZXRBdHQnOiBbJ2EnLCAnYmMnXSB9LFxuICAgICAgICAgICAgJ2NkJyxcbiAgICAgICAgICBdXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmVzb2x2ZXMgdG8gdGhlIHZhbHVlIGlmIG9ubHkgb25lIHZhbHVlIGlzIGpvaW5lZCcsIGFzeW5jVGVzdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoKSwgYW55VmFsdWUsXG4gICAgICAgICAgKGRlbGltaXRlciwgdmFsdWUpID0+IF8uaXNFcXVhbChzdGFjay5yZXNvbHZlKEZuLmpvaW4oZGVsaW1pdGVyLCBbdmFsdWUgYXMgc3RyaW5nXSkpLCB2YWx1ZSksXG4gICAgICAgICksXG4gICAgICAgIHsgdmVyYm9zZTogdHJ1ZSB9LFxuICAgICAgKTtcbiAgICB9KSk7XG5cbiAgICB0ZXN0KCdwcmUtY29uY2F0ZW5hdGVzIHN0cmluZyBsaXRlcmFscycsIGFzeW5jVGVzdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoKSwgZmMuYXJyYXkobm9uRW1wdHlTdHJpbmcsIDEsIDE1KSxcbiAgICAgICAgICAoZGVsaW1pdGVyLCB2YWx1ZXMpID0+IHN0YWNrLnJlc29sdmUoRm4uam9pbihkZWxpbWl0ZXIsIHZhbHVlcykpID09PSB2YWx1ZXMuam9pbihkZWxpbWl0ZXIpLFxuICAgICAgICApLFxuICAgICAgICB7IHZlcmJvc2U6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSkpO1xuXG4gICAgdGVzdCgncHJlLWNvbmNhdGVuYXRlcyBhcm91bmQgdG9rZW5zJywgYXN5bmNUZXN0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZygpLCBmYy5hcnJheShub25FbXB0eVN0cmluZywgMSwgMyksIHRva2VuaXNoLCBmYy5hcnJheShub25FbXB0eVN0cmluZywgMSwgMyksXG4gICAgICAgICAgKGRlbGltaXRlciwgcHJlZml4LCBvYmosIHN1ZmZpeCkgPT5cbiAgICAgICAgICAgIF8uaXNFcXVhbChzdGFjay5yZXNvbHZlKEZuLmpvaW4oZGVsaW1pdGVyLCBbLi4ucHJlZml4LCBzdHJpbmdUb2tlbihvYmopLCAuLi5zdWZmaXhdKSksXG4gICAgICAgICAgICAgIHsgJ0ZuOjpKb2luJzogW2RlbGltaXRlciwgW3ByZWZpeC5qb2luKGRlbGltaXRlciksIG9iaiwgc3VmZml4LmpvaW4oZGVsaW1pdGVyKV1dIH0pLFxuICAgICAgICApLFxuICAgICAgICB7IHZlcmJvc2U6IHRydWUsIHNlZWQ6IDE1Mzk4NzQ2NDUwMDUsIHBhdGg6ICcwOjA6MDowOjA6MDowOjA6MCcgfSxcbiAgICAgICk7XG4gICAgfSkpO1xuXG4gICAgdGVzdCgnZmxhdHRlbnMgam9pbnMgbmVzdGVkIHVuZGVyIGpvaW5zIHdpdGggc2FtZSBkZWxpbWl0ZXInLCBhc3luY1Rlc3QoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKCksIGZjLmFycmF5KGFueVZhbHVlKSxcbiAgICAgICAgICBmYy5hcnJheShhbnlWYWx1ZSwgMSwgMyksXG4gICAgICAgICAgZmMuYXJyYXkoYW55VmFsdWUpLFxuICAgICAgICAgIChkZWxpbWl0ZXIsIHByZWZpeCwgbmVzdGVkLCBzdWZmaXgpID0+XG4gICAgICAgICAgICAvLyBHb25uYSB0ZXN0XG4gICAgICAgICAgICBfLmlzRXF1YWwoc3RhY2sucmVzb2x2ZShGbi5qb2luKGRlbGltaXRlciwgWy4uLnByZWZpeCBhcyBzdHJpbmdbXSwgRm4uam9pbihkZWxpbWl0ZXIsIG5lc3RlZCBhcyBzdHJpbmdbXSksIC4uLnN1ZmZpeCBhcyBzdHJpbmdbXV0pKSxcbiAgICAgICAgICAgICAgc3RhY2sucmVzb2x2ZShGbi5qb2luKGRlbGltaXRlciwgWy4uLnByZWZpeCBhcyBzdHJpbmdbXSwgLi4ubmVzdGVkIGFzIHN0cmluZ1tdLCAuLi5zdWZmaXggYXMgc3RyaW5nW11dKSkpLFxuICAgICAgICApLFxuICAgICAgICB7IHZlcmJvc2U6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSkpO1xuXG4gICAgdGVzdCgnZG9lcyBub3QgZmxhdHRlbiBqb2lucyBuZXN0ZWQgdW5kZXIgam9pbnMgd2l0aCBkaWZmZXJlbnQgZGVsaW1pdGVyJywgYXN5bmNUZXN0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZygpLCBmYy5zdHJpbmcoKSxcbiAgICAgICAgICBmYy5hcnJheShhbnlWYWx1ZSwgMSwgMyksXG4gICAgICAgICAgZmMuYXJyYXkodG9rZW5pc2gsIDIsIDMpLFxuICAgICAgICAgIGZjLmFycmF5KGFueVZhbHVlLCAzKSxcbiAgICAgICAgICAoZGVsaW1pdGVyMSwgZGVsaW1pdGVyMiwgcHJlZml4LCBuZXN0ZWQsIHN1ZmZpeCkgPT4ge1xuICAgICAgICAgICAgZmMucHJlKGRlbGltaXRlcjEgIT09IGRlbGltaXRlcjIpO1xuICAgICAgICAgICAgY29uc3Qgam9pbiA9IEZuLmpvaW4oZGVsaW1pdGVyMSwgWy4uLnByZWZpeCBhcyBzdHJpbmdbXSwgRm4uam9pbihkZWxpbWl0ZXIyLCBzdHJpbmdMaXN0VG9rZW4obmVzdGVkKSksIC4uLnN1ZmZpeCBhcyBzdHJpbmdbXV0pO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBzdGFjay5yZXNvbHZlKGpvaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkWydGbjo6Sm9pbiddWzFdLmZpbmQoKGU6IGFueSkgPT4gdHlwZW9mIGUgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnRm46OkpvaW4nIGluIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVbJ0ZuOjpKb2luJ11bMF0gPT09IGRlbGltaXRlcjIpICE9IG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgICAgKSxcbiAgICAgICAgeyB2ZXJib3NlOiB0cnVlIH0sXG4gICAgICApO1xuICAgIH0pKTtcblxuICAgIHRlc3QoJ0ZuOjpFYWNoTWVtYmVySW4nLCBhc3luY1Rlc3QoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgIGNvbnN0IGVhY2hNZW1iZXJJbiA9IEZuLmNvbmRpdGlvbkVhY2hNZW1iZXJJbihcbiAgICAgICAgRm4udmFsdWVPZkFsbCgnQVdTOjpFQzI6OlN1Ym5ldDo6SWQnLCAnVnBjSWQnKSxcbiAgICAgICAgRm4ucmVmQWxsKCdBV1M6OkVDMjo6VlBDOjpJZCcpLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKGVhY2hNZW1iZXJJbikpLnRvRXF1YWwoe1xuICAgICAgICAnRm46OkVhY2hNZW1iZXJJbic6IFtcbiAgICAgICAgICB7ICdGbjo6VmFsdWVPZkFsbCc6IFsnQVdTOjpFQzI6OlN1Ym5ldDo6SWQnLCAnVnBjSWQnXSB9LFxuICAgICAgICAgIHsgJ0ZuOjpSZWZBbGwnOiAnQVdTOjpFQzI6OlZQQzo6SWQnIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICB0ZXN0KCdjcm9zcy1zdGFjayBGbkpvaW4gZWxlbWVudHMgYXJlIHByb3Blcmx5IHJlc29sdmVkJywgYXN5bmNUZXN0KGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCBhcHAgPSBuZXcgQXBwKCk7XG4gICAgICBjb25zdCBzdGFjazEgPSBuZXcgU3RhY2soYXBwLCAnU3RhY2sxJyk7XG4gICAgICBjb25zdCBzdGFjazIgPSBuZXcgU3RhY2soYXBwLCAnU3RhY2syJyk7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIG5ldyBDZm5PdXRwdXQoc3RhY2syLCAnU3RhY2sxSWQnLCB7XG4gICAgICAgIHZhbHVlOiBGbi5qb2luKCcgPSAnLCBbJ1N0YWNrMUlkJywgc3RhY2sxLnN0YWNrSWRdKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGFwcC5zeW50aCgpLmdldFN0YWNrQnlOYW1lKCdTdGFjazInKS50ZW1wbGF0ZTtcblxuICAgICAgZXhwZWN0KHRlbXBsYXRlPy5PdXRwdXRzKS50b0VxdWFsKHtcbiAgICAgICAgU3RhY2sxSWQ6IHtcbiAgICAgICAgICBWYWx1ZToge1xuICAgICAgICAgICAgJ0ZuOjpKb2luJzogWycgPSAnLCBbXG4gICAgICAgICAgICAgICdTdGFjazFJZCcsXG4gICAgICAgICAgICAgIHsgJ0ZuOjpJbXBvcnRWYWx1ZSc6ICdTdGFjazE6RXhwb3J0c091dHB1dFJlZkFXU1N0YWNrSWRCMkRENUJBQScgfSxcbiAgICAgICAgICAgIF1dLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWYnLCAoKSA9PiB7XG4gICAgdGVzdCgncmV0dXJucyBhIHJlZmVyZW5jZSBnaXZlbiBhIGxvZ2ljYWwgbmFtZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShGbi5yZWYoJ2hlbGxvJykpKS50b0VxdWFsKHtcbiAgICAgICAgUmVmOiAnaGVsbG8nLFxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnbmVzdGVkIEZuOjpKb2luIHdpdGggbGlzdCB0b2tlbicsICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IGlubmVyID0gRm4uam9pbignLCcsIFRva2VuLmFzTGlzdCh7IE5vdFJlYWxseUxpc3Q6IHRydWUgfSkpO1xuICAgIGNvbnN0IG91dGVyID0gRm4uam9pbignLCcsIFtpbm5lciwgJ0ZvbyddKTtcbiAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShvdXRlcikpLnRvRXF1YWwoe1xuICAgICAgJ0ZuOjpKb2luJzogW1xuICAgICAgICAnLCcsXG4gICAgICAgIFtcbiAgICAgICAgICB7ICdGbjo6Sm9pbic6IFsnLCcsIHsgTm90UmVhbGx5TGlzdDogdHJ1ZSB9XSB9LFxuICAgICAgICAgICdGb28nLFxuICAgICAgICBdLFxuICAgICAgXSxcbiAgICB9KTtcbiAgfSk7XG59KTtcblxudGVzdCgnRm4uc3BsaXQgd2l0aCBhbiB1bmtub3duIGxlbmd0aCByZXNvbHZlcyB0byBzaW1wbGUge0ZuOjpTcGxpdH0nLCAoKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgY29uc3Qgc3BsaXR0YWJsZVRva2VuID0gVG9rZW4uYXNTdHJpbmcoeyBUaGlzSXNBU3BsaXR0YWJsZTogJ2xpc3QnIH0pO1xuICBjb25zdCBzcGxpdFRva2VuOiBzdHJpbmdbXSA9IEZuLnNwbGl0KCcsJywgc3BsaXR0YWJsZVRva2VuKTtcblxuICBleHBlY3Qoc3RhY2sucmVzb2x2ZShzcGxpdFRva2VuKSkudG9FcXVhbCh7ICdGbjo6U3BsaXQnOiBbJywnLCB7IFRoaXNJc0FTcGxpdHRhYmxlOiAnbGlzdCcgfV0gfSk7XG59KTtcblxudGVzdCgnRm4uc3BsaXQgd2l0aCBhbiBhc3N1bWVkIGxlbmd0aCByZXNvbHZlcyB0byBhIGxpc3Qgb2Yge0ZuOjpTZWxlY3R9cycsICgpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcblxuICBjb25zdCBzcGxpdHRhYmxlVG9rZW4gPSBUb2tlbi5hc1N0cmluZyh7IFRoaXNJc0FTcGxpdHRhYmxlOiAnbGlzdCcgfSk7XG4gIGNvbnN0IHNwbGl0VG9rZW46IHN0cmluZ1tdID0gRm4uc3BsaXQoJywnLCBzcGxpdHRhYmxlVG9rZW4sIDMpO1xuXG4gIGNvbnN0IHNwbGl0VmFsdWUgPSB7ICdGbjo6U3BsaXQnOiBbJywnLCB7IFRoaXNJc0FTcGxpdHRhYmxlOiAnbGlzdCcgfV0gfTtcbiAgZXhwZWN0KHN0YWNrLnJlc29sdmUoc3BsaXRUb2tlbikpLnRvRXF1YWwoW1xuICAgIHsgJ0ZuOjpTZWxlY3QnOiBbMCwgc3BsaXRWYWx1ZV0gfSxcbiAgICB7ICdGbjo6U2VsZWN0JzogWzEsIHNwbGl0VmFsdWVdIH0sXG4gICAgeyAnRm46OlNlbGVjdCc6IFsyLCBzcGxpdFZhbHVlXSB9LFxuICBdKTtcbn0pO1xuXG50ZXN0KCdGbi5pbXBvcnRMaXN0VmFsdWUgcHJvZHVjZXMgbGlzdHMgb2Yga25vd24gbGVuZ3RoJywgKCkgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuXG4gIGNvbnN0IHNwbGl0VG9rZW46IHN0cmluZ1tdID0gRm4uaW1wb3J0TGlzdFZhbHVlKCdFeHBvcnROYW1lJywgMyk7XG5cbiAgY29uc3Qgc3BsaXRWYWx1ZSA9IHsgJ0ZuOjpTcGxpdCc6IFsnLCcsIHsgJ0ZuOjpJbXBvcnRWYWx1ZSc6ICdFeHBvcnROYW1lJyB9XSB9O1xuICBleHBlY3Qoc3RhY2sucmVzb2x2ZShzcGxpdFRva2VuKSkudG9FcXVhbChbXG4gICAgeyAnRm46OlNlbGVjdCc6IFswLCBzcGxpdFZhbHVlXSB9LFxuICAgIHsgJ0ZuOjpTZWxlY3QnOiBbMSwgc3BsaXRWYWx1ZV0gfSxcbiAgICB7ICdGbjo6U2VsZWN0JzogWzIsIHNwbGl0VmFsdWVdIH0sXG4gIF0pO1xufSk7XG5cbnRlc3QoJ0ZuLnRvSnNvblN0cmluZycsICgpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgY29uc3QgdG9rZW4gPSBUb2tlbi5hc0FueSh7IGtleTogJ3ZhbHVlJyB9KTtcblxuICBleHBlY3Qoc3RhY2sucmVzb2x2ZShGbi50b0pzb25TdHJpbmcodG9rZW4pKSkudG9FcXVhbCh7ICdGbjo6VG9Kc29uU3RyaW5nJzogeyBrZXk6ICd2YWx1ZScgfSB9KTtcbiAgZXhwZWN0KHN0YWNrLnRlbXBsYXRlT3B0aW9ucy50cmFuc2Zvcm1zKS50b0VxdWFsKGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICdBV1M6Okxhbmd1YWdlRXh0ZW5zaW9ucycsXG4gIF0pKTtcbn0pO1xuXG50ZXN0KCdGbi50b0pzb25TdHJpbmcgd2l0aCByZXNvbHZlZCB2YWx1ZScsICgpID0+IHtcbiAgZXhwZWN0KEZuLnRvSnNvblN0cmluZyh7IGtleTogJ3ZhbHVlJyB9KSkudG9FcXVhbCgne1xcXCJrZXlcXFwiOlxcXCJ2YWx1ZVxcXCJ9Jyk7XG59KTtcblxudGVzdCgnRm4ubGVuJywgKCkgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICBjb25zdCB0b2tlbiA9IEZuLnNwbGl0KCd8JywgVG9rZW4uYXNTdHJpbmcoeyBUaGlzSXNBU3BsaXR0YWJsZTogJ2xpc3QnIH0pKTtcblxuICBleHBlY3Qoc3RhY2sucmVzb2x2ZShGbi5sZW4odG9rZW4pKSkudG9FcXVhbCh7XG4gICAgJ0ZuOjpMZW5ndGgnOiB7XG4gICAgICAnRm46OlNwbGl0JzogW1xuICAgICAgICAnfCcsXG4gICAgICAgIHtcbiAgICAgICAgICBUaGlzSXNBU3BsaXR0YWJsZTogJ2xpc3QnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICB9KTtcbiAgZXhwZWN0KHN0YWNrLnRlbXBsYXRlT3B0aW9ucy50cmFuc2Zvcm1zKS50b0VxdWFsKGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICdBV1M6Okxhbmd1YWdlRXh0ZW5zaW9ucycsXG4gIF0pKTtcbn0pO1xuXG50ZXN0KCdGbi5sZW4gd2l0aCByZXNvbHZlZCB2YWx1ZScsICgpID0+IHtcbiAgZXhwZWN0KEZuLmxlbihGbi5zcGxpdCgnfCcsICdhfGJ8YycpKSkudG9CZSgzKTtcbn0pO1xuXG5mdW5jdGlvbiBzdHJpbmdMaXN0VG9rZW4obzogYW55KTogc3RyaW5nW10ge1xuICByZXR1cm4gVG9rZW4uYXNMaXN0KG5ldyBJbnRyaW5zaWMobykpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9rZW4obzogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIFRva2VuLmFzU3RyaW5nKG5ldyBJbnRyaW5zaWMobykpO1xufVxuIl19