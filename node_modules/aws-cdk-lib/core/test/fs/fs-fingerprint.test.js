"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const fs_1 = require("../../lib/fs");
const fingerprint_1 = require("../../lib/fs/fingerprint");
describe('fs fingerprint', () => {
    describe('files', () => {
        test('does not change with the file name', () => {
            // GIVEN
            const workdir = fs.mkdtempSync(path.join(os.tmpdir(), 'hash-tests'));
            const content = 'Hello, world!';
            const input1 = path.join(workdir, 'input1.txt');
            const input2 = path.join(workdir, 'input2.txt');
            const input3 = path.join(workdir, 'input3.txt');
            fs.writeFileSync(input1, content);
            fs.writeFileSync(input2, content);
            fs.writeFileSync(input3, content + '.'); // add one character, hash should be different
            // WHEN
            const hash1 = fs_1.FileSystem.fingerprint(input1);
            const hash2 = fs_1.FileSystem.fingerprint(input2);
            const hash3 = fs_1.FileSystem.fingerprint(input3);
            // THEN
            expect(hash1).toEqual(hash2);
            expect(hash3).not.toEqual(hash1);
        });
        test('works on empty files', () => {
            // GIVEN
            const workdir = fs.mkdtempSync(path.join(os.tmpdir(), 'hash-tests'));
            const input1 = path.join(workdir, 'empty');
            const input2 = path.join(workdir, 'empty');
            fs.writeFileSync(input1, '');
            fs.writeFileSync(input2, '');
            // WHEN
            const hash1 = fs_1.FileSystem.fingerprint(input1);
            const hash2 = fs_1.FileSystem.fingerprint(input2);
            // THEN
            expect(hash1).toEqual(hash2);
        });
    });
    describe('directories', () => {
        test('works on directories', () => {
            // GIVEN
            const srcdir = path.join(__dirname, 'fixtures', 'symlinks');
            const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'copy-tests'));
            fs_1.FileSystem.copyDirectory(srcdir, outdir);
            // WHEN
            const hashSrc = fs_1.FileSystem.fingerprint(srcdir);
            const hashCopy = fs_1.FileSystem.fingerprint(outdir);
            // THEN
            expect(hashSrc).toEqual(hashCopy);
        });
        test('ignores requested files', () => {
            // GIVEN
            const srcdir = path.join(__dirname, 'fixtures', 'symlinks');
            const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'copy-tests'));
            fs_1.FileSystem.copyDirectory(srcdir, outdir);
            // WHEN
            const hashSrc = fs_1.FileSystem.fingerprint(srcdir, { exclude: ['*.ignoreme'] });
            fs.writeFileSync(path.join(outdir, `${hashSrc}.ignoreme`), 'Ignore me!');
            const hashCopy = fs_1.FileSystem.fingerprint(outdir, { exclude: ['*.ignoreme'] });
            // THEN
            expect(hashSrc).toEqual(hashCopy);
        });
        test('changes with file names', () => {
            // GIVEN
            const srcdir = path.join(__dirname, 'fixtures', 'symlinks');
            const cpydir = fs.mkdtempSync(path.join(os.tmpdir(), 'fingerprint-tests'));
            fs_1.FileSystem.copyDirectory(srcdir, cpydir);
            // be careful not to break a symlink
            fs.renameSync(path.join(cpydir, 'normal-dir', 'file-in-subdir.txt'), path.join(cpydir, 'move-me.txt'));
            // WHEN
            const hashSrc = fs_1.FileSystem.fingerprint(srcdir);
            const hashCopy = fs_1.FileSystem.fingerprint(cpydir);
            // THEN
            expect(hashSrc).not.toEqual(hashCopy);
        });
    });
    describe('symlinks', () => {
        test('changes with the contents of followed symlink referent', () => {
            // GIVEN
            const dir1 = fs.mkdtempSync(path.join(os.tmpdir(), 'fingerprint-tests'));
            const dir2 = fs.mkdtempSync(path.join(os.tmpdir(), 'fingerprint-tests'));
            const target = path.join(dir1, 'boom.txt');
            const content = 'boom';
            fs.writeFileSync(target, content);
            fs.symlinkSync(target, path.join(dir2, 'link-to-boom.txt'));
            // now dir2 contains a symlink to a file in dir1
            // WHEN
            const original = fs_1.FileSystem.fingerprint(dir2);
            // now change the contents of the target
            fs.writeFileSync(target, 'changning you!');
            const afterChange = fs_1.FileSystem.fingerprint(dir2);
            // revert the content to original and expect hash to be reverted
            fs.writeFileSync(target, content);
            const afterRevert = fs_1.FileSystem.fingerprint(dir2);
            // THEN
            expect(original).not.toEqual(afterChange);
            expect(afterRevert).toEqual(original);
        });
        test('does not change with the contents of un-followed symlink referent', () => {
            // GIVEN
            const dir1 = fs.mkdtempSync(path.join(os.tmpdir(), 'fingerprint-tests'));
            const dir2 = fs.mkdtempSync(path.join(os.tmpdir(), 'fingerprint-tests'));
            const target = path.join(dir1, 'boom.txt');
            const content = 'boom';
            fs.writeFileSync(target, content);
            fs.symlinkSync(target, path.join(dir2, 'link-to-boom.txt'));
            // now dir2 contains a symlink to a file in dir1
            // WHEN
            const original = fs_1.FileSystem.fingerprint(dir2, { follow: fs_1.SymlinkFollowMode.NEVER });
            // now change the contents of the target
            fs.writeFileSync(target, 'changning you!');
            const afterChange = fs_1.FileSystem.fingerprint(dir2, { follow: fs_1.SymlinkFollowMode.NEVER });
            // revert the content to original and expect hash to be reverted
            fs.writeFileSync(target, content);
            const afterRevert = fs_1.FileSystem.fingerprint(dir2, { follow: fs_1.SymlinkFollowMode.NEVER });
            // THEN
            expect(original).toEqual(afterChange);
            expect(afterRevert).toEqual(original);
        });
    });
    describe('eol', () => {
        test('normalizes line endings', () => {
            // GIVEN
            const lf = path.join(__dirname, 'eol', 'lf.txt');
            const crlf = path.join(__dirname, 'eol', 'crlf.txt');
            fs.writeFileSync(crlf, fs.readFileSync(lf, 'utf8').replace(/\n/g, '\r\n'));
            const lfStat = fs.statSync(lf);
            const crlfStat = fs.statSync(crlf);
            // WHEN
            const crlfHash = (0, fingerprint_1.contentFingerprint)(crlf);
            const lfHash = (0, fingerprint_1.contentFingerprint)(lf);
            // THEN
            expect(crlfStat.size).not.toEqual(lfStat.size); // Difference in size due to different line endings
            expect(crlfHash).toEqual(lfHash); // Same hash
            fs.unlinkSync(crlf);
        });
    });
    // The fingerprint cache is only enabled for node v12 and higher as older
    // versions can have false positive inode comparisons due to floating point
    // rounding error.
    const describe_nodev12 = Number(process.versions.node.split('.')[0]) < 12 ? describe.skip : describe;
    describe_nodev12('fingerprint cache', () => {
        const testString = 'hello world';
        const testFile = path.join(__dirname, 'inode-fp.1');
        // This always-false ternary is just to help typescript infer the type properly
        let openSyncSpy = false ? jest.spyOn(fs, 'openSync') : undefined;
        // Create a very large test file
        beforeAll(() => {
            const file = fs.openSync(testFile, 'w');
            fs.writeSync(file, testString);
            fs.closeSync(file);
            openSyncSpy = jest.spyOn(fs, 'openSync');
        });
        afterAll(() => {
            fs.unlinkSync(testFile);
            openSyncSpy?.mockRestore();
        });
        test('caches fingerprint results', () => {
            const hash1 = fs_1.FileSystem.fingerprint(testFile, {});
            const hash2 = fs_1.FileSystem.fingerprint(testFile, {});
            expect(hash1).toEqual(hash2);
            expect(openSyncSpy).toHaveBeenCalledTimes(1);
        });
        test('considers mtime', () => {
            const hash1 = fs_1.FileSystem.fingerprint(testFile, {});
            const file = fs.openSync(testFile, 'r+');
            fs.writeSync(file, 'foobar');
            fs.closeSync(file);
            // Update mtime to a value that is guaranteed to be different even if the tests run... fast!
            const fileStat = fs.statSync(testFile, { bigint: true });
            fs.utimesSync(testFile, fileStat.atime, new Date(1337));
            const hash2 = fs_1.FileSystem.fingerprint(testFile, {});
            expect(hash1).not.toEqual(hash2);
            expect(openSyncSpy).toHaveBeenCalledTimes(3);
        });
    });
    test('normalizes relative path', () => {
        // Simulate a Windows path.relative()
        const originalPathRelative = path.relative;
        const pathRelativeSpy = jest.spyOn(path, 'relative').mockImplementation((from, to) => {
            return originalPathRelative(from, to).replace(/\//g, '\\');
        });
        const hash1 = fs_1.FileSystem.fingerprint(path.join(__dirname, 'fixtures', 'test1'));
        // Restore Linux behavior
        pathRelativeSpy.mockRestore();
        const hash2 = fs_1.FileSystem.fingerprint(path.join(__dirname, 'fixtures', 'test1'));
        // Relative paths are normalized
        expect(hash1).toEqual(hash2);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMtZmluZ2VycHJpbnQudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZzLWZpbmdlcnByaW50LnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixxQ0FBNkQ7QUFDN0QsMERBQThEO0FBRTlELFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7SUFDOUIsUUFBUSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEdBQUcsRUFBRTtZQUM5QyxRQUFRO1lBQ1IsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQztZQUNoQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNoRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNoRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNoRCxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNsQyxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNsQyxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyw4Q0FBOEM7WUFFdkYsT0FBTztZQUNQLE1BQU0sS0FBSyxHQUFHLGVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDN0MsTUFBTSxLQUFL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QUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9CLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRmlsZVN5c3RlbSwgU3ltbGlua0ZvbGxvd01vZGUgfSBmcm9tICcuLi8uLi9saWIvZnMnO1xuaW1wb3J0IHsgY29udGVudEZpbmdlcnByaW50IH0gZnJvbSAnLi4vLi4vbGliL2ZzL2ZpbmdlcnByaW50JztcblxuZGVzY3JpYmUoJ2ZzIGZpbmdlcnByaW50JywgKCkgPT4ge1xuICBkZXNjcmliZSgnZmlsZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnZG9lcyBub3QgY2hhbmdlIHdpdGggdGhlIGZpbGUgbmFtZScsICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCB3b3JrZGlyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnaGFzaC10ZXN0cycpKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgICBjb25zdCBpbnB1dDEgPSBwYXRoLmpvaW4od29ya2RpciwgJ2lucHV0MS50eHQnKTtcbiAgICAgIGNvbnN0IGlucHV0MiA9IHBhdGguam9pbih3b3JrZGlyLCAnaW5wdXQyLnR4dCcpO1xuICAgICAgY29uc3QgaW5wdXQzID0gcGF0aC5qb2luKHdvcmtkaXIsICdpbnB1dDMudHh0Jyk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGlucHV0MSwgY29udGVudCk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGlucHV0MiwgY29udGVudCk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGlucHV0MywgY29udGVudCArICcuJyk7IC8vIGFkZCBvbmUgY2hhcmFjdGVyLCBoYXNoIHNob3VsZCBiZSBkaWZmZXJlbnRcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgaGFzaDEgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KGlucHV0MSk7XG4gICAgICBjb25zdCBoYXNoMiA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQoaW5wdXQyKTtcbiAgICAgIGNvbnN0IGhhc2gzID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChpbnB1dDMpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3QoaGFzaDEpLnRvRXF1YWwoaGFzaDIpO1xuICAgICAgZXhwZWN0KGhhc2gzKS5ub3QudG9FcXVhbChoYXNoMSk7XG5cbiAgICB9KTtcblxuICAgIHRlc3QoJ3dvcmtzIG9uIGVtcHR5IGZpbGVzJywgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIGNvbnN0IHdvcmtkaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksICdoYXNoLXRlc3RzJykpO1xuICAgICAgY29uc3QgaW5wdXQxID0gcGF0aC5qb2luKHdvcmtkaXIsICdlbXB0eScpO1xuICAgICAgY29uc3QgaW5wdXQyID0gcGF0aC5qb2luKHdvcmtkaXIsICdlbXB0eScpO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhpbnB1dDEsICcnKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoaW5wdXQyLCAnJyk7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIGNvbnN0IGhhc2gxID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChpbnB1dDEpO1xuICAgICAgY29uc3QgaGFzaDIgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KGlucHV0Mik7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChoYXNoMSkudG9FcXVhbChoYXNoMik7XG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RpcmVjdG9yaWVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3dvcmtzIG9uIGRpcmVjdG9yaWVzJywgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIGNvbnN0IHNyY2RpciA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdmaXh0dXJlcycsICdzeW1saW5rcycpO1xuICAgICAgY29uc3Qgb3V0ZGlyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY29weS10ZXN0cycpKTtcbiAgICAgIEZpbGVTeXN0ZW0uY29weURpcmVjdG9yeShzcmNkaXIsIG91dGRpcik7XG5cbiAgICAgIC8vIFdIRU5cbiAgICAgIGNvbnN0IGhhc2hTcmMgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KHNyY2Rpcik7XG4gICAgICBjb25zdCBoYXNoQ29weSA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQob3V0ZGlyKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgZXhwZWN0KGhhc2hTcmMpLnRvRXF1YWwoaGFzaENvcHkpO1xuXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdpZ25vcmVzIHJlcXVlc3RlZCBmaWxlcycsICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCBzcmNkaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZml4dHVyZXMnLCAnc3ltbGlua3MnKTtcbiAgICAgIGNvbnN0IG91dGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2NvcHktdGVzdHMnKSk7XG4gICAgICBGaWxlU3lzdGVtLmNvcHlEaXJlY3Rvcnkoc3JjZGlyLCBvdXRkaXIpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBoYXNoU3JjID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChzcmNkaXIsIHsgZXhjbHVkZTogWycqLmlnbm9yZW1lJ10gfSk7XG5cbiAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKG91dGRpciwgYCR7aGFzaFNyY30uaWdub3JlbWVgKSwgJ0lnbm9yZSBtZSEnKTtcbiAgICAgIGNvbnN0IGhhc2hDb3B5ID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChvdXRkaXIsIHsgZXhjbHVkZTogWycqLmlnbm9yZW1lJ10gfSk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChoYXNoU3JjKS50b0VxdWFsKGhhc2hDb3B5KTtcblxuICAgIH0pO1xuXG4gICAgdGVzdCgnY2hhbmdlcyB3aXRoIGZpbGUgbmFtZXMnLCAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgY29uc3Qgc3JjZGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ2ZpeHR1cmVzJywgJ3N5bWxpbmtzJyk7XG4gICAgICBjb25zdCBjcHlkaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksICdmaW5nZXJwcmludC10ZXN0cycpKTtcbiAgICAgIEZpbGVTeXN0ZW0uY29weURpcmVjdG9yeShzcmNkaXIsIGNweWRpcik7XG5cbiAgICAgIC8vIGJlIGNhcmVmdWwgbm90IHRvIGJyZWFrIGEgc3ltbGlua1xuICAgICAgZnMucmVuYW1lU3luYyhwYXRoLmpvaW4oY3B5ZGlyLCAnbm9ybWFsLWRpcicsICdmaWxlLWluLXN1YmRpci50eHQnKSwgcGF0aC5qb2luKGNweWRpciwgJ21vdmUtbWUudHh0JykpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBoYXNoU3JjID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChzcmNkaXIpO1xuICAgICAgY29uc3QgaGFzaENvcHkgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KGNweWRpcik7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChoYXNoU3JjKS5ub3QudG9FcXVhbChoYXNoQ29weSk7XG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3N5bWxpbmtzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NoYW5nZXMgd2l0aCB0aGUgY29udGVudHMgb2YgZm9sbG93ZWQgc3ltbGluayByZWZlcmVudCcsICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCBkaXIxID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnZmluZ2VycHJpbnQtdGVzdHMnKSk7XG4gICAgICBjb25zdCBkaXIyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnZmluZ2VycHJpbnQtdGVzdHMnKSk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4oZGlyMSwgJ2Jvb20udHh0Jyk7XG4gICAgICBjb25zdCBjb250ZW50ID0gJ2Jvb20nO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGNvbnRlbnQpO1xuICAgICAgZnMuc3ltbGlua1N5bmModGFyZ2V0LCBwYXRoLmpvaW4oZGlyMiwgJ2xpbmstdG8tYm9vbS50eHQnKSk7XG5cbiAgICAgIC8vIG5vdyBkaXIyIGNvbnRhaW5zIGEgc3ltbGluayB0byBhIGZpbGUgaW4gZGlyMVxuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBvcmlnaW5hbCA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQoZGlyMik7XG5cbiAgICAgIC8vIG5vdyBjaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIHRoZSB0YXJnZXRcbiAgICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCAnY2hhbmduaW5nIHlvdSEnKTtcbiAgICAgIGNvbnN0IGFmdGVyQ2hhbmdlID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChkaXIyKTtcblxuICAgICAgLy8gcmV2ZXJ0IHRoZSBjb250ZW50IHRvIG9yaWdpbmFsIGFuZCBleHBlY3QgaGFzaCB0byBiZSByZXZlcnRlZFxuICAgICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGNvbnRlbnQpO1xuICAgICAgY29uc3QgYWZ0ZXJSZXZlcnQgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KGRpcjIpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3Qob3JpZ2luYWwpLm5vdC50b0VxdWFsKGFmdGVyQ2hhbmdlKTtcbiAgICAgIGV4cGVjdChhZnRlclJldmVydCkudG9FcXVhbChvcmlnaW5hbCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkb2VzIG5vdCBjaGFuZ2Ugd2l0aCB0aGUgY29udGVudHMgb2YgdW4tZm9sbG93ZWQgc3ltbGluayByZWZlcmVudCcsICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBjb25zdCBkaXIxID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnZmluZ2VycHJpbnQtdGVzdHMnKSk7XG4gICAgICBjb25zdCBkaXIyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnZmluZ2VycHJpbnQtdGVzdHMnKSk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4oZGlyMSwgJ2Jvb20udHh0Jyk7XG4gICAgICBjb25zdCBjb250ZW50ID0gJ2Jvb20nO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGNvbnRlbnQpO1xuICAgICAgZnMuc3ltbGlua1N5bmModGFyZ2V0LCBwYXRoLmpvaW4oZGlyMiwgJ2xpbmstdG8tYm9vbS50eHQnKSk7XG5cbiAgICAgIC8vIG5vdyBkaXIyIGNvbnRhaW5zIGEgc3ltbGluayB0byBhIGZpbGUgaW4gZGlyMVxuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBvcmlnaW5hbCA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQoZGlyMiwgeyBmb2xsb3c6IFN5bWxpbmtGb2xsb3dNb2RlLk5FVkVSIH0pO1xuXG4gICAgICAvLyBub3cgY2hhbmdlIHRoZSBjb250ZW50cyBvZiB0aGUgdGFyZ2V0XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCwgJ2NoYW5nbmluZyB5b3UhJyk7XG4gICAgICBjb25zdCBhZnRlckNoYW5nZSA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQoZGlyMiwgeyBmb2xsb3c6IFN5bWxpbmtGb2xsb3dNb2RlLk5FVkVSIH0pO1xuXG4gICAgICAvLyByZXZlcnQgdGhlIGNvbnRlbnQgdG8gb3JpZ2luYWwgYW5kIGV4cGVjdCBoYXNoIHRvIGJlIHJldmVydGVkXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCwgY29udGVudCk7XG4gICAgICBjb25zdCBhZnRlclJldmVydCA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQoZGlyMiwgeyBmb2xsb3c6IFN5bWxpbmtGb2xsb3dNb2RlLk5FVkVSIH0pO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3Qob3JpZ2luYWwpLnRvRXF1YWwoYWZ0ZXJDaGFuZ2UpO1xuICAgICAgZXhwZWN0KGFmdGVyUmV2ZXJ0KS50b0VxdWFsKG9yaWdpbmFsKTtcblxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZW9sJywgKCkgPT4ge1xuICAgIHRlc3QoJ25vcm1hbGl6ZXMgbGluZSBlbmRpbmdzJywgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIGNvbnN0IGxmID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ2VvbCcsICdsZi50eHQnKTtcbiAgICAgIGNvbnN0IGNybGYgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZW9sJywgJ2NybGYudHh0Jyk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGNybGYsIGZzLnJlYWRGaWxlU3luYyhsZiwgJ3V0ZjgnKS5yZXBsYWNlKC9cXG4vZywgJ1xcclxcbicpKTtcblxuICAgICAgY29uc3QgbGZTdGF0ID0gZnMuc3RhdFN5bmMobGYpO1xuICAgICAgY29uc3QgY3JsZlN0YXQgPSBmcy5zdGF0U3luYyhjcmxmKTtcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgY3JsZkhhc2ggPSBjb250ZW50RmluZ2VycHJpbnQoY3JsZik7XG4gICAgICBjb25zdCBsZkhhc2ggPSBjb250ZW50RmluZ2VycHJpbnQobGYpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3QoY3JsZlN0YXQuc2l6ZSkubm90LnRvRXF1YWwobGZTdGF0LnNpemUpOyAvLyBEaWZmZXJlbmNlIGluIHNpemUgZHVlIHRvIGRpZmZlcmVudCBsaW5lIGVuZGluZ3NcbiAgICAgIGV4cGVjdChjcmxmSGFzaCkudG9FcXVhbChsZkhhc2gpOyAvLyBTYW1lIGhhc2hcblxuICAgICAgZnMudW5saW5rU3luYyhjcmxmKTtcblxuICAgIH0pO1xuICB9KTtcblxuICAvLyBUaGUgZmluZ2VycHJpbnQgY2FjaGUgaXMgb25seSBlbmFibGVkIGZvciBub2RlIHYxMiBhbmQgaGlnaGVyIGFzIG9sZGVyXG4gIC8vIHZlcnNpb25zIGNhbiBoYXZlIGZhbHNlIHBvc2l0aXZlIGlub2RlIGNvbXBhcmlzb25zIGR1ZSB0byBmbG9hdGluZyBwb2ludFxuICAvLyByb3VuZGluZyBlcnJvci5cbiAgY29uc3QgZGVzY3JpYmVfbm9kZXYxMiA9IE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPCAxMiA/IGRlc2NyaWJlLnNraXAgOiBkZXNjcmliZTtcbiAgZGVzY3JpYmVfbm9kZXYxMignZmluZ2VycHJpbnQgY2FjaGUnLCAoKSA9PiB7XG4gICAgY29uc3QgdGVzdFN0cmluZyA9ICdoZWxsbyB3b3JsZCc7XG4gICAgY29uc3QgdGVzdEZpbGUgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnaW5vZGUtZnAuMScpO1xuICAgIC8vIFRoaXMgYWx3YXlzLWZhbHNlIHRlcm5hcnkgaXMganVzdCB0byBoZWxwIHR5cGVzY3JpcHQgaW5mZXIgdGhlIHR5cGUgcHJvcGVybHlcbiAgICBsZXQgb3BlblN5bmNTcHkgPSBmYWxzZSA/IGplc3Quc3B5T24oZnMsICdvcGVuU3luYycpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gQ3JlYXRlIGEgdmVyeSBsYXJnZSB0ZXN0IGZpbGVcbiAgICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGZzLm9wZW5TeW5jKHRlc3RGaWxlLCAndycpO1xuICAgICAgZnMud3JpdGVTeW5jKGZpbGUsIHRlc3RTdHJpbmcpO1xuICAgICAgZnMuY2xvc2VTeW5jKGZpbGUpO1xuICAgICAgb3BlblN5bmNTcHkgPSBqZXN0LnNweU9uKGZzLCAnb3BlblN5bmMnKTtcbiAgICB9KTtcblxuICAgIGFmdGVyQWxsKCgpID0+IHtcbiAgICAgIGZzLnVubGlua1N5bmModGVzdEZpbGUpO1xuICAgICAgb3BlblN5bmNTcHk/Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjYWNoZXMgZmluZ2VycHJpbnQgcmVzdWx0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc2gxID0gRmlsZVN5c3RlbS5maW5nZXJwcmludCh0ZXN0RmlsZSwge30pO1xuICAgICAgY29uc3QgaGFzaDIgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KHRlc3RGaWxlLCB7fSk7XG5cbiAgICAgIGV4cGVjdChoYXNoMSkudG9FcXVhbChoYXNoMik7XG4gICAgICBleHBlY3Qob3BlblN5bmNTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NvbnNpZGVycyBtdGltZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc2gxID0gRmlsZVN5c3RlbS5maW5nZXJwcmludCh0ZXN0RmlsZSwge30pO1xuXG4gICAgICBjb25zdCBmaWxlID0gZnMub3BlblN5bmModGVzdEZpbGUsICdyKycpO1xuICAgICAgZnMud3JpdGVTeW5jKGZpbGUsICdmb29iYXInKTtcbiAgICAgIGZzLmNsb3NlU3luYyhmaWxlKTtcblxuICAgICAgLy8gVXBkYXRlIG10aW1lIHRvIGEgdmFsdWUgdGhhdCBpcyBndWFyYW50ZWVkIHRvIGJlIGRpZmZlcmVudCBldmVuIGlmIHRoZSB0ZXN0cyBydW4uLi4gZmFzdCFcbiAgICAgIGNvbnN0IGZpbGVTdGF0ID0gZnMuc3RhdFN5bmModGVzdEZpbGUsIHsgYmlnaW50OiB0cnVlIH0pO1xuICAgICAgZnMudXRpbWVzU3luYyh0ZXN0RmlsZSwgZmlsZVN0YXQuYXRpbWUsIG5ldyBEYXRlKDEzMzcpKTtcblxuICAgICAgY29uc3QgaGFzaDIgPSBGaWxlU3lzdGVtLmZpbmdlcnByaW50KHRlc3RGaWxlLCB7fSk7XG5cbiAgICAgIGV4cGVjdChoYXNoMSkubm90LnRvRXF1YWwoaGFzaDIpO1xuICAgICAgZXhwZWN0KG9wZW5TeW5jU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ25vcm1hbGl6ZXMgcmVsYXRpdmUgcGF0aCcsICgpID0+IHtcbiAgICAvLyBTaW11bGF0ZSBhIFdpbmRvd3MgcGF0aC5yZWxhdGl2ZSgpXG4gICAgY29uc3Qgb3JpZ2luYWxQYXRoUmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlO1xuICAgIGNvbnN0IHBhdGhSZWxhdGl2ZVNweSA9IGplc3Quc3B5T24ocGF0aCwgJ3JlbGF0aXZlJykubW9ja0ltcGxlbWVudGF0aW9uKChmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUGF0aFJlbGF0aXZlKGZyb20sIHRvKS5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGhhc2gxID0gRmlsZVN5c3RlbS5maW5nZXJwcmludChwYXRoLmpvaW4oX19kaXJuYW1lLCAnZml4dHVyZXMnLCAndGVzdDEnKSk7XG5cbiAgICAvLyBSZXN0b3JlIExpbnV4IGJlaGF2aW9yXG4gICAgcGF0aFJlbGF0aXZlU3B5Lm1vY2tSZXN0b3JlKCk7XG5cbiAgICBjb25zdCBoYXNoMiA9IEZpbGVTeXN0ZW0uZmluZ2VycHJpbnQocGF0aC5qb2luKF9fZGlybmFtZSwgJ2ZpeHR1cmVzJywgJ3Rlc3QxJykpO1xuXG4gICAgLy8gUmVsYXRpdmUgcGF0aHMgYXJlIG5vcm1hbGl6ZWRcbiAgICBleHBlY3QoaGFzaDEpLnRvRXF1YWwoaGFzaDIpO1xuICB9KTtcbn0pO1xuIl19