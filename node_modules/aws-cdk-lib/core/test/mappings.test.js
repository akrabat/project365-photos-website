"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloud_assembly_schema_1 = require("../../cloud-assembly-schema");
const util_1 = require("./util");
const lib_1 = require("../lib");
describe('mappings', () => {
    test('mappings can be added as another type of entity, and mapping.findInMap can be used to get a token', () => {
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'MyMapping', {
            mapping: {
                TopLevelKey1: {
                    SecondLevelKey1: [1, 2, 3],
                    SecondLevelKey2: { Hello: 'World' },
                },
                TopLevelKey2: {
                    SecondLevelKey1: [99, 99, 99],
                },
            },
        });
        // findInMap can be used to take a reference
        new lib_1.CfnResource(stack, 'MyResource', {
            type: 'R',
            properties: {
                RefToValueInMap: mapping.findInMap('TopLevelKey1', 'SecondLevelKey1'),
            },
        });
        expect(() => mapping.findInMap('NotFoundTopLevel', 'NotFound')).toThrow('Mapping doesn\'t contain top-level key \'NotFoundTopLevel\'');
        expect(() => mapping.findInMap('TopLevelKey1', 'NotFound')).toThrow('Mapping doesn\'t contain second-level key \'NotFound\'');
        // set value can be used to set/modify a specific value
        mapping.setValue('TopLevelKey2', 'SecondLevelKey2', 'Hi');
        mapping.setValue('TopLevelKey1', 'SecondLevelKey1', [1, 2, 3, 4]);
        expect((0, util_1.toCloudFormation)(stack)).toEqual({
            Mappings: {
                MyMapping: {
                    TopLevelKey1: {
                        SecondLevelKey1: [1, 2, 3, 4],
                        SecondLevelKey2: { Hello: 'World' },
                    },
                    TopLevelKey2: { SecondLevelKey1: [99, 99, 99], SecondLevelKey2: 'Hi' },
                },
            },
            Resources: {
                MyResource: {
                    Type: 'R',
                    Properties: {
                        RefToValueInMap: { 'Fn::FindInMap': ['MyMapping', 'TopLevelKey1', 'SecondLevelKey1'] },
                    },
                },
            },
        });
    });
    test('allow using unresolved tokens in find-in-map', () => {
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    instanceCount: 12,
                },
            },
        });
        const v1 = mapping.findInMap(lib_1.Aws.REGION, 'instanceCount');
        const v2 = lib_1.Fn.findInMap(mapping.logicalId, lib_1.Aws.REGION, 'instanceCount');
        const expected = { 'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'instanceCount'] };
        expect(stack.resolve(v1)).toEqual(expected);
        expect(stack.resolve(v2)).toEqual(expected);
        expect((0, util_1.toCloudFormation)(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    instanceCount: 12,
                },
            },
        });
    });
    test('no validation if first key is token and second is a static string', () => {
        // GIVEN
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
        // WHEN
        const v = mapping.findInMap(lib_1.Aws.REGION, 'size');
        // THEN
        expect(stack.resolve(v)).toEqual({
            'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'size'],
        });
        expect((0, util_1.toCloudFormation)(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
    });
    test('validate first key if it is a string and second is a token', () => {
        // GIVEN
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
        // WHEN
        const v = mapping.findInMap(lib_1.Aws.REGION, 'size');
        // THEN
        expect(() => mapping.findInMap('not-found', 'size')).toThrow(/Mapping doesn't contain top-level key 'not-found'/);
        expect(stack.resolve(v)).toEqual({ 'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'size'] });
        expect((0, util_1.toCloudFormation)(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
    });
    test('throws if mapping attribute name not alphanumeric', () => {
        const stack = new lib_1.Stack();
        expect(() => new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                size: {
                    'us-east-1': 12,
                },
            },
        })).toThrowError(/Attribute name 'us-east-1' must contain only alphanumeric characters./);
    });
    test('using the value of a mapping in a different stack copies the mapping to the consuming stack', () => {
        const app = new lib_1.App();
        const creationStack = new lib_1.Stack(app, 'creationStack');
        const consumingStack = new lib_1.Stack(app, 'consumingStack');
        const mapping = new lib_1.CfnMapping(creationStack, 'MyMapping', {
            mapping: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        new lib_1.CfnOutput(consumingStack, 'Output', {
            value: mapping.findInMap('boo', 'bah'),
        });
        const v1 = mapping.findInMap('boo', 'bah');
        let v2 = lib_1.Fn.findInMap(mapping.logicalId, 'boo', 'bah');
        const creationStackExpected = { 'Fn::FindInMap': ['MyMapping', 'boo', 'bah'] };
        expect(creationStack.resolve(v1)).toEqual(creationStackExpected);
        expect(creationStack.resolve(v2)).toEqual(creationStackExpected);
        expect((0, util_1.toCloudFormation)(creationStack).Mappings).toEqual({
            MyMapping: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        const mappingCopyLogicalId = 'MappingCopyMyMappingc843c23de60b3672d919ab3e4cb2c14042794164d8';
        v2 = lib_1.Fn.findInMap(mappingCopyLogicalId, 'boo', 'bah');
        const consumingStackExpected = { 'Fn::FindInMap': [mappingCopyLogicalId, 'boo', 'bah'] };
        expect(consumingStack.resolve(v1)).toEqual(consumingStackExpected);
        expect(consumingStack.resolve(v2)).toEqual(consumingStackExpected);
        expect((0, util_1.toCloudFormation)(consumingStack).Mappings).toEqual({
            [mappingCopyLogicalId]: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        expect((0, util_1.toCloudFormation)(consumingStack).Outputs).toEqual({
            Output: {
                Value: {
                    'Fn::FindInMap': [
                        mappingCopyLogicalId,
                        'boo',
                        'bah',
                    ],
                },
            },
        });
    });
});
describe('lazy mapping', () => {
    let stack;
    let mapping;
    const backing = {
        TopLevelKey1: {
            SecondLevelKey1: [1, 2, 3],
            SecondLevelKey2: { Hello: 'World' },
        },
    };
    beforeEach(() => {
        stack = new lib_1.Stack();
        mapping = new lib_1.CfnMapping(stack, 'Lazy Mapping', {
            mapping: backing,
            lazy: true,
        });
    });
    it('does not create CfnMapping if findInMap keys can be resolved', () => {
        const retrievedValue = mapping.findInMap('TopLevelKey1', 'SecondLevelKey1');
        expect(stack.resolve(retrievedValue)).toStrictEqual([1, 2, 3]);
        expect((0, util_1.toCloudFormation)(stack)).toStrictEqual({});
    });
    it('does not create CfnMapping if findInMap is not called', () => {
        expect((0, util_1.toCloudFormation)(stack)).toStrictEqual({});
    });
    it('creates CfnMapping if top level key cannot be resolved', () => {
        const retrievedValue = mapping.findInMap(lib_1.Aws.REGION, 'SecondLevelKey1');
        expect(stack.resolve(retrievedValue)).toStrictEqual({ 'Fn::FindInMap': ['LazyMapping', { Ref: 'AWS::Region' }, 'SecondLevelKey1'] });
        expect((0, util_1.toCloudFormation)(stack)).toStrictEqual({
            Mappings: {
                LazyMapping: backing,
            },
        });
    });
    it('creates CfnMapping if second level key cannot be resolved', () => {
        const retrievedValue = mapping.findInMap('TopLevelKey1', lib_1.Aws.REGION);
        expect(stack.resolve(retrievedValue)).toStrictEqual({ 'Fn::FindInMap': ['LazyMapping', 'TopLevelKey1', { Ref: 'AWS::Region' }] });
        expect((0, util_1.toCloudFormation)(stack)).toStrictEqual({
            Mappings: {
                LazyMapping: backing,
            },
        });
    });
    it('throws if keys can be resolved but are not found in backing', () => {
        expect(() => mapping.findInMap('NonExistentKey', 'SecondLevelKey1'))
            .toThrowError(/Mapping doesn't contain top-level key .*/);
        expect(() => mapping.findInMap('TopLevelKey1', 'NonExistentKey'))
            .toThrowError(/Mapping doesn't contain second-level key .*/);
    });
});
describe('eager by default', () => {
    const backing = {
        TopLevelKey1: {
            SecondLevelKey1: [1, 2, 3],
            SecondLevelKey2: { Hello: 'World' },
        },
    };
    let app;
    let stack;
    let mapping;
    beforeEach(() => {
        app = new lib_1.App();
        stack = new lib_1.Stack(app, 'Stack');
        mapping = new lib_1.CfnMapping(stack, 'Lazy Mapping', {
            mapping: backing,
        });
    });
    it('emits warning if no findInMap called', () => {
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([{
                path: '/Stack/Lazy Mapping',
                message: 'Consider making this CfnMapping a lazy mapping by providing `lazy: true`: either no findInMap was called or every findInMap could be immediately resolved without using Fn::FindInMap',
            }]);
    });
    it('emits warning if every findInMap resolves immediately', () => {
        mapping.findInMap('TopLevelKey1', 'SecondLevelKey1');
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([{
                path: '/Stack/Lazy Mapping',
                message: 'Consider making this CfnMapping a lazy mapping by providing `lazy: true`: either no findInMap was called or every findInMap could be immediately resolved without using Fn::FindInMap',
            }]);
    });
    it('does not emit warning if a findInMap could not resolve immediately', () => {
        mapping.findInMap('TopLevelKey1', lib_1.Aws.REGION);
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([]);
    });
});
function getInfoAnnotations(casm) {
    const result = new Array();
    for (const stack of Object.values(casm.manifest.artifacts ?? {})) {
        for (const [path, md] of Object.entries(stack.metadata ?? {})) {
            for (const x of md) {
                if (x.type === cloud_assembly_schema_1.ArtifactMetadataEntryType.INFO) {
                    result.push({ path, message: x.data });
                }
            }
        }
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGluZ3MudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1hcHBpbmdzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx1RUFBd0U7QUFFeEUsaUNBQTBDO0FBQzFDLGdDQUFpRjtBQUVqRixRQUFRLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRTtJQUN4QixJQUFJLENBQUMsbUdBQW1HLEVBQUUsR0FBRyxFQUFFO1FBQzdHLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFDMUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxnQkFBVSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7WUFDakQsT0FBTyxFQUFFO2dCQUNQLFlBQVksRUFBRTtvQkFDWixlQUFlLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUIsZUFBZSxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtpQkFDcEM7Z0JBQ0QsWUFBWSxFQUFFO29CQUNaLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2lCQUM5QjthQUNGO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsNENBQTRDO1FBQzVDLElBQUksaUJBQVcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFO1lBQ25DLElBQUksRUFBRSxHQUFHO1lBQ1QsVUFBVSxFQUFFO2dCQUNWLGVBQWUsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQzthQUN0RTtTQUNGLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLDZEQUE2RCxDQUFDLENBQUM7UUFDdkksTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFD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Q0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxrQkFBa0IsQ0FBQyxJQUFtQjtJQUM3QyxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBcUMsQ0FBQztJQUM5RCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLEVBQUU7UUFDaEUsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRTtZQUM3RCxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLGlEQUF5QixDQUFDLElBQUksRUFBRTtvQkFDN0MsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQWMsRUFBRSxDQUFDLENBQUM7aUJBQ2xEO2FBQ0Y7U0FDRjtLQUNGO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUgfSBmcm9tICcuLi8uLi9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHsgQ2xvdWRBc3NlbWJseSB9IGZyb20gJy4uLy4uL2N4LWFwaSc7XG5pbXBvcnQgeyB0b0Nsb3VkRm9ybWF0aW9uIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IEFwcCwgQXdzLCBDZm5NYXBwaW5nLCBDZm5SZXNvdXJjZSwgQ2ZuT3V0cHV0LCBGbiwgU3RhY2sgfSBmcm9tICcuLi9saWInO1xuXG5kZXNjcmliZSgnbWFwcGluZ3MnLCAoKSA9PiB7XG4gIHRlc3QoJ21hcHBpbmdzIGNhbiBiZSBhZGRlZCBhcyBhbm90aGVyIHR5cGUgb2YgZW50aXR5LCBhbmQgbWFwcGluZy5maW5kSW5NYXAgY2FuIGJlIHVzZWQgdG8gZ2V0IGEgdG9rZW4nLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCBtYXBwaW5nID0gbmV3IENmbk1hcHBpbmcoc3RhY2ssICdNeU1hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgIFRvcExldmVsS2V5MToge1xuICAgICAgICAgIFNlY29uZExldmVsS2V5MTogWzEsIDIsIDNdLFxuICAgICAgICAgIFNlY29uZExldmVsS2V5MjogeyBIZWxsbzogJ1dvcmxkJyB9LFxuICAgICAgICB9LFxuICAgICAgICBUb3BMZXZlbEtleTI6IHtcbiAgICAgICAgICBTZWNvbmRMZXZlbEtleTE6IFs5OSwgOTksIDk5XSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBmaW5kSW5NYXAgY2FuIGJlIHVzZWQgdG8gdGFrZSBhIHJlZmVyZW5jZVxuICAgIG5ldyBDZm5SZXNvdXJjZShzdGFjaywgJ015UmVzb3VyY2UnLCB7XG4gICAgICB0eXBlOiAnUicsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIFJlZlRvVmFsdWVJbk1hcDogbWFwcGluZy5maW5kSW5NYXAoJ1RvcExldmVsS2V5MScsICdTZWNvbmRMZXZlbEtleTEnKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgZXhwZWN0KCgpID0+IG1hcHBpbmcuZmluZEluTWFwKCdOb3RGb3VuZFRvcExldmVsJywgJ05vdEZvdW5kJykpLnRvVGhyb3coJ01hcHBpbmcgZG9lc25cXCd0IGNvbnRhaW4gdG9wLWxldmVsIGtleSBcXCdOb3RGb3VuZFRvcExldmVsXFwnJyk7XG4gICAgZXhwZWN0KCgpID0+IG1hcHBpbmcuZmluZEluTWFwKCdUb3BMZXZlbEtleTEnLCAnTm90Rm91bmQnKSkudG9UaHJvdygnTWFwcGluZyBkb2VzblxcJ3QgY29udGFpbiBzZWNvbmQtbGV2ZWwga2V5IFxcJ05vdEZvdW5kXFwnJyk7XG5cbiAgICAvLyBzZXQgdmFsdWUgY2FuIGJlIHVzZWQgdG8gc2V0L21vZGlmeSBhIHNwZWNpZmljIHZhbHVlXG4gICAgbWFwcGluZy5zZXRWYWx1ZSgnVG9wTGV2ZWxLZXkyJywgJ1NlY29uZExldmVsS2V5MicsICdIaScpO1xuICAgIG1hcHBpbmcuc2V0VmFsdWUoJ1RvcExldmVsS2V5MScsICdTZWNvbmRMZXZlbEtleTEnLCBbMSwgMiwgMywgNF0pO1xuXG4gICAgZXhwZWN0KHRvQ2xvdWRGb3JtYXRpb24oc3RhY2spKS50b0VxdWFsKHtcbiAgICAgIE1hcHBpbmdzOlxuICAgICAge1xuICAgICAgICBNeU1hcHBpbmc6XG4gICAgICAgICB7XG4gICAgICAgICAgIFRvcExldmVsS2V5MTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBTZWNvbmRMZXZlbEtleTE6IFsxLCAyLCAzLCA0XSxcbiAgICAgICAgICAgIFNlY29uZExldmVsS2V5MjogeyBIZWxsbzogJ1dvcmxkJyB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgIFRvcExldmVsS2V5MjogeyBTZWNvbmRMZXZlbEtleTE6IFs5OSwgOTksIDk5XSwgU2Vjb25kTGV2ZWxLZXkyOiAnSGknIH0sXG4gICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFJlc291cmNlczpcbiAgICAgIHtcbiAgICAgICAgTXlSZXNvdXJjZTpcbiAgICAgICAgIHtcbiAgICAgICAgICAgVHlwZTogJ1InLFxuICAgICAgICAgICBQcm9wZXJ0aWVzOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlZlRvVmFsdWVJbk1hcDpcbiAgICAgICAgICAgeyAnRm46OkZpbmRJbk1hcCc6IFsnTXlNYXBwaW5nJywgJ1RvcExldmVsS2V5MScsICdTZWNvbmRMZXZlbEtleTEnXSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnYWxsb3cgdXNpbmcgdW5yZXNvbHZlZCB0b2tlbnMgaW4gZmluZC1pbi1tYXAnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcblxuICAgIGNvbnN0IG1hcHBpbmcgPSBuZXcgQ2ZuTWFwcGluZyhzdGFjaywgJ21hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgICd1cy1lYXN0LTEnOiB7XG4gICAgICAgICAgaW5zdGFuY2VDb3VudDogMTIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgdjEgPSBtYXBwaW5nLmZpbmRJbk1hcChBd3MuUkVHSU9OLCAnaW5zdGFuY2VDb3VudCcpO1xuICAgIGNvbnN0IHYyID0gRm4uZmluZEluTWFwKG1hcHBpbmcubG9naWNhbElkLCBBd3MuUkVHSU9OLCAnaW5zdGFuY2VDb3VudCcpO1xuXG4gICAgY29uc3QgZXhwZWN0ZWQgPSB7ICdGbjo6RmluZEluTWFwJzogWydtYXBwaW5nJywgeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgJ2luc3RhbmNlQ291bnQnXSB9O1xuICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKHYxKSkudG9FcXVhbChleHBlY3RlZCk7XG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUodjIpKS50b0VxdWFsKGV4cGVjdGVkKTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykuTWFwcGluZ3MpLnRvRXF1YWwoe1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICAndXMtZWFzdC0xJzoge1xuICAgICAgICAgIGluc3RhbmNlQ291bnQ6IDEyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnbm8gdmFsaWRhdGlvbiBpZiBmaXJzdCBrZXkgaXMgdG9rZW4gYW5kIHNlY29uZCBpcyBhIHN0YXRpYyBzdHJpbmcnLCAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IG1hcHBpbmcgPSBuZXcgQ2ZuTWFwcGluZyhzdGFjaywgJ21hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgICd1cy1lYXN0LTEnOiB7XG4gICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHYgPSBtYXBwaW5nLmZpbmRJbk1hcChBd3MuUkVHSU9OLCAnc2l6ZScpO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKHYpKS50b0VxdWFsKHtcbiAgICAgICdGbjo6RmluZEluTWFwJzogWydtYXBwaW5nJywgeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgJ3NpemUnXSxcbiAgICB9KTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykuTWFwcGluZ3MpLnRvRXF1YWwoe1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICAndXMtZWFzdC0xJzoge1xuICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgndmFsaWRhdGUgZmlyc3Qga2V5IGlmIGl0IGlzIGEgc3RyaW5nIGFuZCBzZWNvbmQgaXMgYSB0b2tlbicsICgpID0+IHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgbWFwcGluZyA9IG5ldyBDZm5NYXBwaW5nKHN0YWNrLCAnbWFwcGluZycsIHtcbiAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgJ3VzLWVhc3QtMSc6IHtcbiAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgdiA9IG1hcHBpbmcuZmluZEluTWFwKEF3cy5SRUdJT04sICdzaXplJyk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KCgpID0+IG1hcHBpbmcuZmluZEluTWFwKCdub3QtZm91bmQnLCAnc2l6ZScpKS50b1Rocm93KC9NYXBwaW5nIGRvZXNuJ3QgY29udGFpbiB0b3AtbGV2ZWwga2V5ICdub3QtZm91bmQnLyk7XG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUodikpLnRvRXF1YWwoeyAnRm46OkZpbmRJbk1hcCc6IFsnbWFwcGluZycsIHsgUmVmOiAnQVdTOjpSZWdpb24nIH0sICdzaXplJ10gfSk7XG4gICAgZXhwZWN0KHRvQ2xvdWRGb3JtYXRpb24oc3RhY2spLk1hcHBpbmdzKS50b0VxdWFsKHtcbiAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgJ3VzLWVhc3QtMSc6IHtcbiAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ3Rocm93cyBpZiBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lIG5vdCBhbHBoYW51bWVyaWMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBleHBlY3QoKCkgPT4gbmV3IENmbk1hcHBpbmcoc3RhY2ssICdtYXBwaW5nJywge1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgJ3VzLWVhc3QtMSc6IDEyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KSkudG9UaHJvd0Vycm9yKC9BdHRyaWJ1dGUgbmFtZSAndXMtZWFzdC0xJyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4vKTtcbiAgfSk7XG5cbiAgdGVzdCgndXNpbmcgdGhlIHZhbHVlIG9mIGEgbWFwcGluZyBpbiBhIGRpZmZlcmVudCBzdGFjayBjb3BpZXMgdGhlIG1hcHBpbmcgdG8gdGhlIGNvbnN1bWluZyBzdGFjaycsICgpID0+IHtcbiAgICBjb25zdCBhcHAgPSBuZXcgQXBwKCk7XG4gICAgY29uc3QgY3JlYXRpb25TdGFjayA9IG5ldyBTdGFjayhhcHAsICdjcmVhdGlvblN0YWNrJyk7XG4gICAgY29uc3QgY29uc3VtaW5nU3RhY2sgPSBuZXcgU3RhY2soYXBwLCAnY29uc3VtaW5nU3RhY2snKTtcblxuICAgIGNvbnN0IG1hcHBpbmcgPSBuZXcgQ2ZuTWFwcGluZyhjcmVhdGlvblN0YWNrLCAnTXlNYXBwaW5nJywge1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICBib286IHtcbiAgICAgICAgICBiYWg6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIG5ldyBDZm5PdXRwdXQoY29uc3VtaW5nU3RhY2ssICdPdXRwdXQnLCB7XG4gICAgICB2YWx1ZTogbWFwcGluZy5maW5kSW5NYXAoJ2JvbycsICdiYWgnKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHYxID0gbWFwcGluZy5maW5kSW5NYXAoJ2JvbycsICdiYWgnKTtcbiAgICBsZXQgdjIgPSBGbi5maW5kSW5NYXAobWFwcGluZy5sb2dpY2FsSWQsICdib28nLCAnYmFoJyk7XG5cbiAgICBjb25zdCBjcmVhdGlvblN0YWNrRXhwZWN0ZWQgPSB7ICdGbjo6RmluZEluTWFwJzogWydNeU1hcHBpbmcnLCAnYm9vJywgJ2JhaCddIH07XG4gICAgZXhwZWN0KGNyZWF0aW9uU3RhY2sucmVzb2x2ZSh2MSkpLnRvRXF1YWwoY3JlYXRpb25TdGFja0V4cGVjdGVkKTtcbiAgICBleHBlY3QoY3JlYXRpb25TdGFjay5yZXNvbHZlKHYyKSkudG9FcXVhbChjcmVhdGlvblN0YWNrRXhwZWN0ZWQpO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKGNyZWF0aW9uU3RhY2spLk1hcHBpbmdzKS50b0VxdWFsKHtcbiAgICAgIE15TWFwcGluZzoge1xuICAgICAgICBib286IHtcbiAgICAgICAgICBiYWg6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1hcHBpbmdDb3B5TG9naWNhbElkID0gJ01hcHBpbmdDb3B5TXlNYXBwaW5nYzg0M2MyM2RlNjBiMzY3MmQ5MTlhYjNlNGNiMmMxNDA0Mjc5NDE2NGQ4JztcbiAgICB2MiA9IEZuLmZpbmRJbk1hcChtYXBwaW5nQ29weUxvZ2ljYWxJZCwgJ2JvbycsICdiYWgnKTtcbiAgICBjb25zdCBjb25zdW1pbmdTdGFja0V4cGVjdGVkID0geyAnRm46OkZpbmRJbk1hcCc6IFttYXBwaW5nQ29weUxvZ2ljYWxJZCwgJ2JvbycsICdiYWgnXSB9O1xuXG4gICAgZXhwZWN0KGNvbnN1bWluZ1N0YWNrLnJlc29sdmUodjEpKS50b0VxdWFsKGNvbnN1bWluZ1N0YWNrRXhwZWN0ZWQpO1xuICAgIGV4cGVjdChjb25zdW1pbmdTdGFjay5yZXNvbHZlKHYyKSkudG9FcXVhbChjb25zdW1pbmdTdGFja0V4cGVjdGVkKTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihjb25zdW1pbmdTdGFjaykuTWFwcGluZ3MpLnRvRXF1YWwoe1xuICAgICAgW21hcHBpbmdDb3B5TG9naWNhbElkXToge1xuICAgICAgICBib286IHtcbiAgICAgICAgICBiYWg6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihjb25zdW1pbmdTdGFjaykuT3V0cHV0cykudG9FcXVhbCh7XG4gICAgICBPdXRwdXQ6IHtcbiAgICAgICAgVmFsdWU6IHtcbiAgICAgICAgICAnRm46OkZpbmRJbk1hcCc6IFtcbiAgICAgICAgICAgIG1hcHBpbmdDb3B5TG9naWNhbElkLFxuICAgICAgICAgICAgJ2JvbycsXG4gICAgICAgICAgICAnYmFoJyxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2xhenkgbWFwcGluZycsICgpID0+IHtcbiAgbGV0IHN0YWNrOiBTdGFjaztcbiAgbGV0IG1hcHBpbmc6IENmbk1hcHBpbmc7XG4gIGNvbnN0IGJhY2tpbmcgPSB7XG4gICAgVG9wTGV2ZWxLZXkxOiB7XG4gICAgICBTZWNvbmRMZXZlbEtleTE6IFsxLCAyLCAzXSxcbiAgICAgIFNlY29uZExldmVsS2V5MjogeyBIZWxsbzogJ1dvcmxkJyB9LFxuICAgIH0sXG4gIH07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBtYXBwaW5nID0gbmV3IENmbk1hcHBpbmcoc3RhY2ssICdMYXp5IE1hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiBiYWNraW5nLFxuICAgICAgbGF6eTogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ2RvZXMgbm90IGNyZWF0ZSBDZm5NYXBwaW5nIGlmIGZpbmRJbk1hcCBrZXlzIGNhbiBiZSByZXNvbHZlZCcsICgpID0+IHtcbiAgICBjb25zdCByZXRyaWV2ZWRWYWx1ZSA9IG1hcHBpbmcuZmluZEluTWFwKCdUb3BMZXZlbEtleTEnLCAnU2Vjb25kTGV2ZWxLZXkxJyk7XG5cbiAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShyZXRyaWV2ZWRWYWx1ZSkpLnRvU3RyaWN0RXF1YWwoWzEsIDIsIDNdKTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykpLnRvU3RyaWN0RXF1YWwoe30pO1xuICB9KTtcblxuICBpdCgnZG9lcyBub3QgY3JlYXRlIENmbk1hcHBpbmcgaWYgZmluZEluTWFwIGlzIG5vdCBjYWxsZWQnLCAoKSA9PiB7XG4gICAgZXhwZWN0KHRvQ2xvdWRGb3JtYXRpb24oc3RhY2spKS50b1N0cmljdEVxdWFsKHt9KTtcbiAgfSk7XG5cbiAgaXQoJ2NyZWF0ZXMgQ2ZuTWFwcGluZyBpZiB0b3AgbGV2ZWwga2V5IGNhbm5vdCBiZSByZXNvbHZlZCcsICgpID0+IHtcbiAgICBjb25zdCByZXRyaWV2ZWRWYWx1ZSA9IG1hcHBpbmcuZmluZEluTWFwKEF3cy5SRUdJT04sICdTZWNvbmRMZXZlbEtleTEnKTtcblxuICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKHJldHJpZXZlZFZhbHVlKSkudG9TdHJpY3RFcXVhbCh7ICdGbjo6RmluZEluTWFwJzogWydMYXp5TWFwcGluZycsIHsgUmVmOiAnQVdTOjpSZWdpb24nIH0sICdTZWNvbmRMZXZlbEtleTEnXSB9KTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykpLnRvU3RyaWN0RXF1YWwoe1xuICAgICAgTWFwcGluZ3M6IHtcbiAgICAgICAgTGF6eU1hcHBpbmc6IGJhY2tpbmcsXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnY3JlYXRlcyBDZm5NYXBwaW5nIGlmIHNlY29uZCBsZXZlbCBrZXkgY2Fubm90IGJlIHJlc29sdmVkJywgKCkgPT4ge1xuICAgIGNvbnN0IHJldHJpZXZlZFZhbHVlID0gbWFwcGluZy5maW5kSW5NYXAoJ1RvcExldmVsS2V5MScsIEF3cy5SRUdJT04pO1xuXG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUocmV0cmlldmVkVmFsdWUpKS50b1N0cmljdEVxdWFsKHsgJ0ZuOjpGaW5kSW5NYXAnOiBbJ0xhenlNYXBwaW5nJywgJ1RvcExldmVsS2V5MScsIHsgUmVmOiAnQVdTOjpSZWdpb24nIH1dIH0pO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKHN0YWNrKSkudG9TdHJpY3RFcXVhbCh7XG4gICAgICBNYXBwaW5nczoge1xuICAgICAgICBMYXp5TWFwcGluZzogYmFja2luZyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCd0aHJvd3MgaWYga2V5cyBjYW4gYmUgcmVzb2x2ZWQgYnV0IGFyZSBub3QgZm91bmQgaW4gYmFja2luZycsICgpID0+IHtcbiAgICBleHBlY3QoKCkgPT4gbWFwcGluZy5maW5kSW5NYXAoJ05vbkV4aXN0ZW50S2V5JywgJ1NlY29uZExldmVsS2V5MScpKVxuICAgICAgLnRvVGhyb3dFcnJvcigvTWFwcGluZyBkb2Vzbid0IGNvbnRhaW4gdG9wLWxldmVsIGtleSAuKi8pO1xuICAgIGV4cGVjdCgoKSA9PiBtYXBwaW5nLmZpbmRJbk1hcCgnVG9wTGV2ZWxLZXkxJywgJ05vbkV4aXN0ZW50S2V5JykpXG4gICAgICAudG9UaHJvd0Vycm9yKC9NYXBwaW5nIGRvZXNuJ3QgY29udGFpbiBzZWNvbmQtbGV2ZWwga2V5IC4qLyk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdlYWdlciBieSBkZWZhdWx0JywgKCkgPT4ge1xuICBjb25zdCBiYWNraW5nID0ge1xuICAgIFRvcExldmVsS2V5MToge1xuICAgICAgU2Vjb25kTGV2ZWxLZXkxOiBbMSwgMiwgM10sXG4gICAgICBTZWNvbmRMZXZlbEtleTI6IHsgSGVsbG86ICdXb3JsZCcgfSxcbiAgICB9LFxuICB9O1xuXG4gIGxldCBhcHA6IEFwcDtcbiAgbGV0IHN0YWNrOiBTdGFjaztcbiAgbGV0IG1hcHBpbmc6IENmbk1hcHBpbmc7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgYXBwID0gbmV3IEFwcCgpO1xuICAgIHN0YWNrID0gbmV3IFN0YWNrKGFwcCwgJ1N0YWNrJyk7XG4gICAgbWFwcGluZyA9IG5ldyBDZm5NYXBwaW5nKHN0YWNrLCAnTGF6eSBNYXBwaW5nJywge1xuICAgICAgbWFwcGluZzogYmFja2luZyxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ2VtaXRzIHdhcm5pbmcgaWYgbm8gZmluZEluTWFwIGNhbGxlZCcsICgpID0+IHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGFwcC5zeW50aCgpO1xuXG4gICAgZXhwZWN0KGdldEluZm9Bbm5vdGF0aW9ucyhhc3NlbWJseSkpLnRvU3RyaWN0RXF1YWwoW3tcbiAgICAgIHBhdGg6ICcvU3RhY2svTGF6eSBNYXBwaW5nJyxcbiAgICAgIG1lc3NhZ2U6ICdDb25zaWRlciBtYWtpbmcgdGhpcyBDZm5NYXBwaW5nIGEgbGF6eSBtYXBwaW5nIGJ5IHByb3ZpZGluZyBgbGF6eTogdHJ1ZWA6IGVpdGhlciBubyBmaW5kSW5NYXAgd2FzIGNhbGxlZCBvciBldmVyeSBmaW5kSW5NYXAgY291bGQgYmUgaW1tZWRpYXRlbHkgcmVzb2x2ZWQgd2l0aG91dCB1c2luZyBGbjo6RmluZEluTWFwJyxcbiAgICB9XSk7XG4gIH0pO1xuXG4gIGl0KCdlbWl0cyB3YXJuaW5nIGlmIGV2ZXJ5IGZpbmRJbk1hcCByZXNvbHZlcyBpbW1lZGlhdGVseScsICgpID0+IHtcbiAgICBtYXBwaW5nLmZpbmRJbk1hcCgnVG9wTGV2ZWxLZXkxJywgJ1NlY29uZExldmVsS2V5MScpO1xuXG4gICAgY29uc3QgYXNzZW1ibHkgPSBhcHAuc3ludGgoKTtcblxuICAgIGV4cGVjdChnZXRJbmZvQW5ub3RhdGlvbnMoYXNzZW1ibHkpKS50b1N0cmljdEVxdWFsKFt7XG4gICAgICBwYXRoOiAnL1N0YWNrL0xhenkgTWFwcGluZycsXG4gICAgICBtZXNzYWdlOiAnQ29uc2lkZXIgbWFraW5nIHRoaXMgQ2ZuTWFwcGluZyBhIGxhenkgbWFwcGluZyBieSBwcm92aWRpbmcgYGxhenk6IHRydWVgOiBlaXRoZXIgbm8gZmluZEluTWFwIHdhcyBjYWxsZWQgb3IgZXZlcnkgZmluZEluTWFwIGNvdWxkIGJlIGltbWVkaWF0ZWx5IHJlc29sdmVkIHdpdGhvdXQgdXNpbmcgRm46OkZpbmRJbk1hcCcsXG4gICAgfV0pO1xuICB9KTtcblxuICBpdCgnZG9lcyBub3QgZW1pdCB3YXJuaW5nIGlmIGEgZmluZEluTWFwIGNvdWxkIG5vdCByZXNvbHZlIGltbWVkaWF0ZWx5JywgKCkgPT4ge1xuICAgIG1hcHBpbmcuZmluZEluTWFwKCdUb3BMZXZlbEtleTEnLCBBd3MuUkVHSU9OKTtcblxuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXBwLnN5bnRoKCk7XG5cbiAgICBleHBlY3QoZ2V0SW5mb0Fubm90YXRpb25zKGFzc2VtYmx5KSkudG9TdHJpY3RFcXVhbChbXSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGdldEluZm9Bbm5vdGF0aW9ucyhjYXNtOiBDbG91ZEFzc2VtYmx5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTx7IHBhdGg6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nIH0+KCk7XG4gIGZvciAoY29uc3Qgc3RhY2sgb2YgT2JqZWN0LnZhbHVlcyhjYXNtLm1hbmlmZXN0LmFydGlmYWN0cyA/PyB7fSkpIHtcbiAgICBmb3IgKGNvbnN0IFtwYXRoLCBtZF0gb2YgT2JqZWN0LmVudHJpZXMoc3RhY2subWV0YWRhdGEgPz8ge30pKSB7XG4gICAgICBmb3IgKGNvbnN0IHggb2YgbWQpIHtcbiAgICAgICAgaWYgKHgudHlwZSA9PT0gQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZS5JTkZPKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBwYXRoLCBtZXNzYWdlOiB4LmRhdGEgYXMgc3RyaW5nIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=