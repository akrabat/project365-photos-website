"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const feats = require("../lib/features");
const flag_modeling_1 = require("../lib/private/flag-modeling");
test('all future flags have defaults configured', () => {
    Object.keys(feats.FLAGS).forEach(flag => {
        expect(typeof (feats.futureFlagDefault(flag))).toEqual('boolean');
    });
});
test('futureFlagDefault returns false if non existent flag was given', () => {
    expect(feats.futureFlagDefault('non-existent-flag')).toEqual(false);
});
test('feature flag defaults may not be changed anymore', () => {
    // In principle, these flags were decided upon during the v2 alpha period, and they are now frozen
    // and may not be changed anymore.
    //
    // One exception is allowed: to avoid a double negative in your flag name (`disableOldBehavior: true`).
    //
    // In that case, it is permitted to name the flag `oldBehavior`, add a new default set to `true`,
    // and have the recommended value be `false`.
    expect(feats.CURRENT_VERSION_FLAG_DEFAULTS).toEqual({
        // V1->V2 defaults below here
        [feats.APIGATEWAY_USAGEPLANKEY_ORDERINSENSITIVE_ID]: true,
        [feats.ENABLE_STACK_NAME_DUPLICATES_CONTEXT]: true,
        [feats.ENABLE_DIFF_NO_FAIL_CONTEXT]: true,
        [feats.STACK_RELATIVE_EXPORTS_CONTEXT]: true,
        [feats.NEW_STYLE_STACK_SYNTHESIS_CONTEXT]: true,
        [feats.DOCKER_IGNORE_SUPPORT]: true,
        [feats.SECRETS_MANAGER_PARSE_OWNED_SECRET_NAME]: true,
        [feats.KMS_DEFAULT_KEY_POLICIES]: true,
        [feats.S3_GRANT_WRITE_WITHOUT_ACL]: true,
        [feats.ECS_REMOVE_DEFAULT_DESIRED_COUNT]: true,
        [feats.RDS_LOWERCASE_DB_IDENTIFIER]: true,
        [feats.EFS_DEFAULT_ENCRYPTION_AT_REST]: true,
        [feats.LAMBDA_RECOGNIZE_VERSION_PROPS]: true,
        [feats.CLOUDFRONT_DEFAULT_SECURITY_POLICY_TLS_V1_2_2021]: true,
        // Add new disabling feature flags below this line
        // ...
    });
});
test('expired feature flags may not be changed anymore', () => {
    expect(feats.CURRENT_VERSION_EXPIRED_FLAGS).toEqual([
        feats.DOCKER_IGNORE_SUPPORT,
        feats.ECS_REMOVE_DEFAULT_DESIRED_COUNT,
        feats.EFS_DEFAULT_ENCRYPTION_AT_REST,
        feats.ENABLE_DIFF_NO_FAIL_CONTEXT,
        feats.ENABLE_STACK_NAME_DUPLICATES_CONTEXT,
        feats.KMS_DEFAULT_KEY_POLICIES,
        feats.S3_GRANT_WRITE_WITHOUT_ACL,
        feats.SECRETS_MANAGER_PARSE_OWNED_SECRET_NAME,
    ].sort());
});
test.each([
    ['1.2.3', '1.2.3', 0],
    ['1.2.3', '1.2.4', -1],
    ['1.2.3', '2.0.0', -1],
    ['100.2.3', '2.0.0', 1],
    ['V2NEXT', 'V2NEXT', 0],
    ['1.0.0', 'V2NEXT', -1],
    ['2.100.0', 'V2NEXT', -1],
    ['3.100.0', 'V2NEXT', 1],
])('compareVersions(%p, %p) -> %p (and the reverse)', (a, b, expected) => {
    expect((0, flag_modeling_1.compareVersions)(a, b)).toEqual(expected);
    expect((0, flag_modeling_1.compareVersions)(b, a)).toBeCloseTo(-expected, 10); // Gets around expect(-0).toEqual(0) failing... :x
});
const currentv2 = JSON.parse(fs.readFileSync(path.join(__dirname, '../../../../version.v2.json'), { encoding: 'utf-8' })).version;
describe(`introducedIn.v2 is either <= ${currentv2} or magic value "${flag_modeling_1.MAGIC_V2NEXT}"`, () => {
    test.each(Object.keys(feats.FLAGS))('for flag %p', flag => {
        const v2In = feats.FLAGS[flag].introducedIn.v2;
        if (v2In === undefined || v2In === flag_modeling_1.MAGIC_V2NEXT) {
            return;
        }
        // If defined and not magic, it must be in the past w.r.t. the current v2 version
        expect((0, flag_modeling_1.compareVersions)(v2In, currentv2)).not.toEqual(1);
    });
});
test('features.ts should not contain a reference to the constant with the magic value', () => {
    // If it did, the above test would succeed but we would not be able to substitute the string at bump time
    const featuresSourceFile = path.join(__dirname, '..', 'lib', 'features.ts');
    expect(fs.readFileSync(featuresSourceFile, { encoding: 'utf-8' })).not.toContain('MAGIC_V2NEXT');
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmVhdHVyZXMudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZlYXR1cmVzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QyxnRUFBNkU7QUFFN0UsSUFBSSxDQUFDLDJDQUEyQyxFQUFFLEdBQUcsRUFBRTtJQUNyRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdEMsTUFBTSxDQUFDLE9BQU0sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRSxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLGdFQUFnRSxFQUFFLEdBQUcsRUFBRTtJQUMxRSxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEUsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsa0RBQWtELEVBQUUsR0FBRyxFQUFFO0lBQzVELGtHQUFrRztJQUNsRyxrQ0FBa0M7SUFDbEMsRUFBRTtJQUNGLHVHQUF1RztJQUN2RyxFQUFFO0lBQ0YsaUdBQWlHO0lBQ2pHLDZDQUE2QztJQUM3QyxNQUFNLENBQUMsS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUMsT0FBTyxDQUFDO1FBQ2xELDZCQUE2QjtRQUM3QixDQUFDLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxFQUFFLElBQUk7UUFDekQsQ0FBQyxLQUFLLENBQUMsb0NBQW9DLENBQUMsRUFBRSxJQUFJO1FBQ2xELENBQUMsS0FBSyxDQUFDLDJCQUEyQixDQUFDLEVBQUUsSUFBSTtRQUN6QyxDQUFDLEtBQUssQ0FBQyw4QkFB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QUksQ0FBQyxFQUFFO1FBQ3hELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztRQUMvQyxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLDRCQUFZLEVBQUU7WUFDL0MsT0FBTztTQUNSO1FBRUQsaUZBQWlGO1FBQ2pGLE1BQU0sQ0FBQyxJQUFBLCtCQUFlLEVBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLGlGQUFpRixFQUFFLEdBQUcsRUFBRTtJQUMzRix5R0FBeUc7SUFDekcsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQzVFLE1BQU0sQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ25HLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZlYXRzIGZyb20gJy4uL2xpYi9mZWF0dXJlcyc7XG5pbXBvcnQgeyBNQUdJQ19WMk5FWFQsIGNvbXBhcmVWZXJzaW9ucyB9IGZyb20gJy4uL2xpYi9wcml2YXRlL2ZsYWctbW9kZWxpbmcnO1xuXG50ZXN0KCdhbGwgZnV0dXJlIGZsYWdzIGhhdmUgZGVmYXVsdHMgY29uZmlndXJlZCcsICgpID0+IHtcbiAgT2JqZWN0LmtleXMoZmVhdHMuRkxBR1MpLmZvckVhY2goZmxhZyA9PiB7XG4gICAgZXhwZWN0KHR5cGVvZihmZWF0cy5mdXR1cmVGbGFnRGVmYXVsdChmbGFnKSkpLnRvRXF1YWwoJ2Jvb2xlYW4nKTtcbiAgfSk7XG59KTtcblxudGVzdCgnZnV0dXJlRmxhZ0RlZmF1bHQgcmV0dXJucyBmYWxzZSBpZiBub24gZXhpc3RlbnQgZmxhZyB3YXMgZ2l2ZW4nLCAoKSA9PiB7XG4gIGV4cGVjdChmZWF0cy5mdXR1cmVGbGFnRGVmYXVsdCgnbm9uLWV4aXN0ZW50LWZsYWcnKSkudG9FcXVhbChmYWxzZSk7XG59KTtcblxudGVzdCgnZmVhdHVyZSBmbGFnIGRlZmF1bHRzIG1heSBub3QgYmUgY2hhbmdlZCBhbnltb3JlJywgKCkgPT4ge1xuICAvLyBJbiBwcmluY2lwbGUsIHRoZXNlIGZsYWdzIHdlcmUgZGVjaWRlZCB1cG9uIGR1cmluZyB0aGUgdjIgYWxwaGEgcGVyaW9kLCBhbmQgdGhleSBhcmUgbm93IGZyb3plblxuICAvLyBhbmQgbWF5IG5vdCBiZSBjaGFuZ2VkIGFueW1vcmUuXG4gIC8vXG4gIC8vIE9uZSBleGNlcHRpb24gaXMgYWxsb3dlZDogdG8gYXZvaWQgYSBkb3VibGUgbmVnYXRpdmUgaW4geW91ciBmbGFnIG5hbWUgKGBkaXNhYmxlT2xkQmVoYXZpb3I6IHRydWVgKS5cbiAgLy9cbiAgLy8gSW4gdGhhdCBjYXNlLCBpdCBpcyBwZXJtaXR0ZWQgdG8gbmFtZSB0aGUgZmxhZyBgb2xkQmVoYXZpb3JgLCBhZGQgYSBuZXcgZGVmYXVsdCBzZXQgdG8gYHRydWVgLFxuICAvLyBhbmQgaGF2ZSB0aGUgcmVjb21tZW5kZWQgdmFsdWUgYmUgYGZhbHNlYC5cbiAgZXhwZWN0KGZlYXRzLkNVUlJFTlRfVkVSU0lPTl9GTEFHX0RFRkFVTFRTKS50b0VxdWFsKHtcbiAgICAvLyBWMS0+VjIgZGVmYXVsdHMgYmVsb3cgaGVyZVxuICAgIFtmZWF0cy5BUElHQVRFV0FZX1VTQUdFUExBTktFWV9PUkRFUklOU0VOU0lUSVZFX0lEXTogdHJ1ZSxcbiAgICBbZmVhdHMuRU5BQkxFX1NUQUNLX05BTUVfRFVQTElDQVRFU19DT05URVhUXTogdHJ1ZSxcbiAgICBbZmVhdHMuRU5BQkxFX0RJRkZfTk9fRkFJTF9DT05URVhUXTogdHJ1ZSxcbiAgICBbZmVhdHMuU1RBQ0tfUkVMQVRJVkVfRVhQT1JUU19DT05URVhUXTogdHJ1ZSxcbiAgICBbZmVhdHMuTkVXX1NUWUxFX1NUQUNLX1NZTlRIRVNJU19DT05URVhUXTogdHJ1ZSxcbiAgICBbZmVhdHMuRE9DS0VSX0lHTk9SRV9TVVBQT1JUXTogdHJ1ZSxcbiAgICBbZmVhdHMuU0VDUkVUU19NQU5BR0VSX1BBUlNFX09XTkVEX1NFQ1JFVF9OQU1FXTogdHJ1ZSxcbiAgICBbZmVhdHMuS01TX0RFRkFVTFRfS0VZX1BPTElDSUVTXTogdHJ1ZSxcbiAgICBbZmVhdHMuUzNfR1JBTlRfV1JJVEVfV0lUSE9VVF9BQ0xdOiB0cnVlLFxuICAgIFtmZWF0cy5FQ1NfUkVNT1ZFX0RFRkFVTFRfREVTSVJFRF9DT1VOVF06IHRydWUsXG4gICAgW2ZlYXRzLlJEU19MT1dFUkNBU0VfREJfSURFTlRJRklFUl06IHRydWUsXG4gICAgW2ZlYXRzLkVGU19ERUZBVUxUX0VOQ1JZUFRJT05fQVRfUkVTVF06IHRydWUsXG4gICAgW2ZlYXRzLkxBTUJEQV9SRUNPR05JWkVfVkVSU0lPTl9QUk9QU106IHRydWUsXG4gICAgW2ZlYXRzLkNMT1VERlJPTlRfREVGQVVMVF9TRUNVUklUWV9QT0xJQ1lfVExTX1YxXzJfMjAyMV06IHRydWUsXG4gICAgLy8gQWRkIG5ldyBkaXNhYmxpbmcgZmVhdHVyZSBmbGFncyBiZWxvdyB0aGlzIGxpbmVcbiAgICAvLyAuLi5cblxuICB9KTtcbn0pO1xuXG50ZXN0KCdleHBpcmVkIGZlYXR1cmUgZmxhZ3MgbWF5IG5vdCBiZSBjaGFuZ2VkIGFueW1vcmUnLCAoKSA9PiB7XG4gIGV4cGVjdChmZWF0cy5DVVJSRU5UX1ZFUlNJT05fRVhQSVJFRF9GTEFHUykudG9FcXVhbChbXG4gICAgZmVhdHMuRE9DS0VSX0lHTk9SRV9TVVBQT1JULFxuICAgIGZlYXRzLkVDU19SRU1PVkVfREVGQVVMVF9ERVNJUkVEX0NPVU5ULFxuICAgIGZlYXRzLkVGU19ERUZBVUxUX0VOQ1JZUFRJT05fQVRfUkVTVCxcbiAgICBmZWF0cy5FTkFCTEVfRElGRl9OT19GQUlMX0NPTlRFWFQsXG4gICAgZmVhdHMuRU5BQkxFX1NUQUNLX05BTUVfRFVQTElDQVRFU19DT05URVhULFxuICAgIGZlYXRzLktNU19ERUZBVUxUX0tFWV9QT0xJQ0lFUyxcbiAgICBmZWF0cy5TM19HUkFOVF9XUklURV9XSVRIT1VUX0FDTCxcbiAgICBmZWF0cy5TRUNSRVRTX01BTkFHRVJfUEFSU0VfT1dORURfU0VDUkVUX05BTUUsXG4gIF0uc29ydCgpKTtcbn0pO1xuXG50ZXN0LmVhY2goW1xuICBbJzEuMi4zJywgJzEuMi4zJywgMF0sXG4gIFsnMS4yLjMnLCAnMS4yLjQnLCAtMV0sXG4gIFsnMS4yLjMnLCAnMi4wLjAnLCAtMV0sXG4gIFsnMTAwLjIuMycsICcyLjAuMCcsIDFdLFxuICBbJ1YyTkVYVCcsICdWMk5FWFQnLCAwXSxcbiAgWycxLjAuMCcsICdWMk5FWFQnLCAtMV0sXG4gIFsnMi4xMDAuMCcsICdWMk5FWFQnLCAtMV0sXG4gIFsnMy4xMDAuMCcsICdWMk5FWFQnLCAxXSxcbl0pKCdjb21wYXJlVmVyc2lvbnMoJXAsICVwKSAtPiAlcCAoYW5kIHRoZSByZXZlcnNlKScsIChhLCBiLCBleHBlY3RlZCkgPT4ge1xuICBleHBlY3QoY29tcGFyZVZlcnNpb25zKGEsIGIpKS50b0VxdWFsKGV4cGVjdGVkKTtcbiAgZXhwZWN0KGNvbXBhcmVWZXJzaW9ucyhiLCBhKSkudG9CZUNsb3NlVG8oLWV4cGVjdGVkLCAxMCk7IC8vIEdldHMgYXJvdW5kIGV4cGVjdCgtMCkudG9FcXVhbCgwKSBmYWlsaW5nLi4uIDp4XG59KTtcblxuY29uc3QgY3VycmVudHYyOiBzdHJpbmcgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vLi4vLi4vLi4vdmVyc2lvbi52Mi5qc29uJyksIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSkpLnZlcnNpb247XG5cbmRlc2NyaWJlKGBpbnRyb2R1Y2VkSW4udjIgaXMgZWl0aGVyIDw9ICR7Y3VycmVudHYyfSBvciBtYWdpYyB2YWx1ZSBcIiR7TUFHSUNfVjJORVhUfVwiYCwgKCkgPT4ge1xuICB0ZXN0LmVhY2goT2JqZWN0LmtleXMoZmVhdHMuRkxBR1MpKSgnZm9yIGZsYWcgJXAnLCBmbGFnID0+IHtcbiAgICBjb25zdCB2MkluID0gZmVhdHMuRkxBR1NbZmxhZ10uaW50cm9kdWNlZEluLnYyO1xuICAgIGlmICh2MkluID09PSB1bmRlZmluZWQgfHwgdjJJbiA9PT0gTUFHSUNfVjJORVhUKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZGVmaW5lZCBhbmQgbm90IG1hZ2ljLCBpdCBtdXN0IGJlIGluIHRoZSBwYXN0IHcuci50LiB0aGUgY3VycmVudCB2MiB2ZXJzaW9uXG4gICAgZXhwZWN0KGNvbXBhcmVWZXJzaW9ucyh2MkluLCBjdXJyZW50djIpKS5ub3QudG9FcXVhbCgxKTtcbiAgfSk7XG59KTtcblxudGVzdCgnZmVhdHVyZXMudHMgc2hvdWxkIG5vdCBjb250YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdGFudCB3aXRoIHRoZSBtYWdpYyB2YWx1ZScsICgpID0+IHtcbiAgLy8gSWYgaXQgZGlkLCB0aGUgYWJvdmUgdGVzdCB3b3VsZCBzdWNjZWVkIGJ1dCB3ZSB3b3VsZCBub3QgYmUgYWJsZSB0byBzdWJzdGl0dXRlIHRoZSBzdHJpbmcgYXQgYnVtcCB0aW1lXG4gIGNvbnN0IGZlYXR1cmVzU291cmNlRmlsZSA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICdsaWInLCAnZmVhdHVyZXMudHMnKTtcbiAgZXhwZWN0KGZzLnJlYWRGaWxlU3luYyhmZWF0dXJlc1NvdXJjZUZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSkpLm5vdC50b0NvbnRhaW4oJ01BR0lDX1YyTkVYVCcpO1xufSk7Il19