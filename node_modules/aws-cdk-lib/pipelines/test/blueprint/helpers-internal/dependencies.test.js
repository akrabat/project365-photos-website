"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
describe('with nested graphs', () => {
    const graph = (0, util_1.mkGraph)('G', G => {
        let aa;
        const A = G.graph('A', [], GA => {
            aa = GA.node('aa');
        });
        // B -> A, (same-level dependency)
        G.graph('B', [A], B => {
            // bbb -> bb
            const bb = B.node('bb');
            B.node('bbb', [bb]);
        });
        // cc -> aa (cross-subgraph dependency)
        G.graph('C', [], C => {
            C.node('cc', [aa]);
        });
        // D -> aa (down-dependency)
        G.graph('D', [aa], C => {
            C.node('dd', [aa]);
        });
        // ee -> A (up-dependency)
        G.graph('E', [], C => {
            C.node('ee', [A]);
        });
    });
    test('can get up-projected dependency list from graph', () => {
        const sorted = graph.sortedChildren();
        expect((0, util_1.nodeNames)(sorted)).toEqual([
            ['A'],
            ['B', 'C', 'D', 'E'],
        ]);
    });
    test('can get down-projected dependency list from graph', () => {
        const sorted = graph.sortedLeaves();
        expect((0, util_1.nodeNames)(sorted)).toEqual([
            ['aa'],
            ['bb', 'cc', 'dd', 'ee'],
            ['bbb'],
        ]);
    });
});
test('duplicate dependencies are ignored', () => {
    (0, util_1.mkGraph)('G', G => {
        const A = G.graph('A', [], GA => {
            GA.node('aa');
        });
        // parent graph depnds on A also
        const B = G.graph('B', [A], GB => {
            // duplicate dependency on A
            GB.graph('BB', [A], GBB => {
                GBB.node('bbb');
            });
            GB.node('bb');
        });
        expect((0, util_1.nodeNames)(B.tryGetChild('BB').allDeps)).toStrictEqual(['A']);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jaWVzLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXBlbmRlbmNpZXMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUE0QztBQUc1QyxRQUFRLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFO0lBQ2xDLE1BQU0sS0FBSyxHQUFHLElBQUEsY0FBTyxFQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRTtRQUM3QixJQUFJLEVBQWtCLENBQUM7UUFFdkIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzlCLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO1FBRUgsa0NBQWtDO1FBQ2xDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7WUFDcEIsWUFBWTtZQUNaLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDeEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBRUgsdUNBQXVDO1FBQ3ZDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRTtZQUNuQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7UUFFSCw0QkFBNEI7UUFDNUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtZQUN0QixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7UUFFSCwwQkFBMEI7UUFDMUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFO1lBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLGlEQUFpRCxFQUFFLEdBQUcsRUFBRTtRQUMzRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFdEMsTUFBTSxDQUFDLElBQUEsZ0JBQVMsRUFBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxDQUFDLEdBQUcsQ0FBQztZQUNMLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO1NBQ3JCLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLG1EQUFtRCxFQUFFLEdBQUcsRUFBRTtRQUM3RCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEMsTUFBTSxDQUFDLElBQUEsZ0JBQVMsRUFBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxDQUFDLElBQUksQ0FBQztZQUNOLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1lBQ3hCLENBQUMsS0FBSyxDQUFDO1NBQ1IsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxHQUFHLEVBQUU7SUFDOUMsSUFBQSxjQUFPLEVBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFO1FBQ2YsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzlCLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxnQ0FBZ0M7UUFDaEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtZQUMvQiw0QkFBNEI7WUFDNUIsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsQixDQUFDLENBQUMsQ0FBQztZQUNILEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsSUFBQSxnQkFBUyxFQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBta0dyYXBoLCBub2RlTmFtZXMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgR3JhcGhOb2RlIH0gZnJvbSAnLi4vLi4vLi4vbGliL2hlbHBlcnMtaW50ZXJuYWwnO1xuXG5kZXNjcmliZSgnd2l0aCBuZXN0ZWQgZ3JhcGhzJywgKCkgPT4ge1xuICBjb25zdCBncmFwaCA9IG1rR3JhcGgoJ0cnLCBHID0+IHtcbiAgICBsZXQgYWE6IEdyYXBoTm9kZTxhbnk+O1xuXG4gICAgY29uc3QgQSA9IEcuZ3JhcGgoJ0EnLCBbXSwgR0EgPT4ge1xuICAgICAgYWEgPSBHQS5ub2RlKCdhYScpO1xuICAgIH0pO1xuXG4gICAgLy8gQiAtPiBBLCAoc2FtZS1sZXZlbCBkZXBlbmRlbmN5KVxuICAgIEcuZ3JhcGgoJ0InLCBbQV0sIEIgPT4ge1xuICAgICAgLy8gYmJiIC0+IGJiXG4gICAgICBjb25zdCBiYiA9IEIubm9kZSgnYmInKTtcbiAgICAgIEIubm9kZSgnYmJiJywgW2JiXSk7XG4gICAgfSk7XG5cbiAgICAvLyBjYyAtPiBhYSAoY3Jvc3Mtc3ViZ3JhcGggZGVwZW5kZW5jeSlcbiAgICBHLmdyYXBoKCdDJywgW10sIEMgPT4ge1xuICAgICAgQy5ub2RlKCdjYycsIFthYV0pO1xuICAgIH0pO1xuXG4gICAgLy8gRCAtPiBhYSAoZG93bi1kZXBlbmRlbmN5KVxuICAgIEcuZ3JhcGgoJ0QnLCBbYWEhXSwgQyA9PiB7XG4gICAgICBDLm5vZGUoJ2RkJywgW2FhXSk7XG4gICAgfSk7XG5cbiAgICAvLyBlZSAtPiBBICh1cC1kZXBlbmRlbmN5KVxuICAgIEcuZ3JhcGgoJ0UnLCBbXSwgQyA9PiB7XG4gICAgICBDLm5vZGUoJ2VlJywgW0FdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnY2FuIGdldCB1cC1wcm9qZWN0ZWQgZGVwZW5kZW5jeSBsaXN0IGZyb20gZ3JhcGgnLCAoKSA9PiB7XG4gICAgY29uc3Qgc29ydGVkID0gZ3JhcGguc29ydGVkQ2hpbGRyZW4oKTtcblxuICAgIGV4cGVjdChub2RlTmFtZXMoc29ydGVkKSkudG9FcXVhbChbXG4gICAgICBbJ0EnXSxcbiAgICAgIFsnQicsICdDJywgJ0QnLCAnRSddLFxuICAgIF0pO1xuICB9KTtcblxuICB0ZXN0KCdjYW4gZ2V0IGRvd24tcHJvamVjdGVkIGRlcGVuZGVuY3kgbGlzdCBmcm9tIGdyYXBoJywgKCkgPT4ge1xuICAgIGNvbnN0IHNvcnRlZCA9IGdyYXBoLnNvcnRlZExlYXZlcygpO1xuICAgIGV4cGVjdChub2RlTmFtZXMoc29ydGVkKSkudG9FcXVhbChbXG4gICAgICBbJ2FhJ10sXG4gICAgICBbJ2JiJywgJ2NjJywgJ2RkJywgJ2VlJ10sXG4gICAgICBbJ2JiYiddLFxuICAgIF0pO1xuICB9KTtcbn0pO1xuXG50ZXN0KCdkdXBsaWNhdGUgZGVwZW5kZW5jaWVzIGFyZSBpZ25vcmVkJywgKCkgPT4ge1xuICBta0dyYXBoKCdHJywgRyA9PiB7XG4gICAgY29uc3QgQSA9IEcuZ3JhcGgoJ0EnLCBbXSwgR0EgPT4ge1xuICAgICAgR0Eubm9kZSgnYWEnKTtcbiAgICB9KTtcblxuICAgIC8vIHBhcmVudCBncmFwaCBkZXBuZHMgb24gQSBhbHNvXG4gICAgY29uc3QgQiA9IEcuZ3JhcGgoJ0InLCBbQV0sIEdCID0+IHtcbiAgICAgIC8vIGR1cGxpY2F0ZSBkZXBlbmRlbmN5IG9uIEFcbiAgICAgIEdCLmdyYXBoKCdCQicsIFtBXSwgR0JCID0+IHtcbiAgICAgICAgR0JCLm5vZGUoJ2JiYicpO1xuICAgICAgfSk7XG4gICAgICBHQi5ub2RlKCdiYicpO1xuICAgIH0pO1xuXG4gICAgZXhwZWN0KG5vZGVOYW1lcyhCLnRyeUdldENoaWxkKCdCQicpIS5hbGxEZXBzKSkudG9TdHJpY3RFcXVhbChbJ0EnXSk7XG4gIH0pO1xufSk7XG4iXX0=