{
  "version": 3,
  "sources": ["../../../../src/constructs/abstracts/AwsConstruct.ts"],
  "sourcesContent": ["import { Construct as CdkConstruct } from \"constructs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport type { ConstructInterface } from \"@lift/constructs\";\nimport { get, isArray, isEmpty, isObject } from \"lodash\";\nimport { paths } from \"traverse\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport ServerlessError from \"../../utils/error\";\n\nexport abstract class AwsConstruct extends CdkConstruct implements ConstructInterface {\n    private applyExtensions(extensions: Record<string, unknown>) {\n        const availableExtensions = this.extend();\n        if (isEmpty(extensions) || isEmpty(availableExtensions)) {\n            return;\n        }\n        Object.entries(extensions).forEach(([extensionKey, extensionObject]) => {\n            if (!Object.keys(availableExtensions).includes(extensionKey)) {\n                throw new ServerlessError(\n                    `There is no extension '${extensionKey}' available on this construct. Available extensions are: ${Object.keys(\n                        availableExtensions\n                    ).join(\", \")}.`,\n                    \"LIFT_UNKNOWN_EXTENSION\"\n                );\n            }\n            if (isObject(extensionObject)) {\n                const accumulatedPathsPointingToArray: string[] = [];\n                paths(extensionObject)\n                    .filter((path) => !isEmpty(path))\n                    .map((path) => {\n                        return path.join(\".\");\n                    })\n                    .filter((path) => {\n                        if (\n                            accumulatedPathsPointingToArray.some((previouslySelectedPath) =>\n                                path.startsWith(previouslySelectedPath)\n                            )\n                        ) {\n                            return false;\n                        }\n\n                        const pointedValue: unknown = get(extensionObject, path);\n                        const isPathPointingToArray = isArray(pointedValue);\n                        if (isPathPointingToArray) {\n                            accumulatedPathsPointingToArray.push(path);\n\n                            return true;\n                        }\n\n                        const isPathPointingToLeaf = !isObject(pointedValue);\n\n                        return isPathPointingToLeaf;\n                    })\n                    .map((path) => {\n                        availableExtensions[extensionKey].addOverride(path, get(extensionObject, path));\n                    });\n            }\n        });\n    }\n\n    static create<C extends AwsConstruct = AwsConstruct>(\n        this: {\n            new (\n                scope: CdkConstruct,\n                id: string,\n                configuration: { extensions?: Record<string, unknown> } & Record<string, unknown>,\n                provider: AwsProvider\n            ): C;\n        },\n        provider: AwsProvider,\n        id: string,\n        configuration: { extensions?: Record<string, unknown> } & Record<string, unknown>\n    ): C {\n        /**\n         * We are passing a `configuration` of type `Record<string, unknown>` to a parameter\n         * of stricter type. This is theoretically invalid.\n         *\n         * In practice however, `configuration` has been validated with the exact JSON schema\n         * of the construct. And that construct has generated the type for `configuration` based\n         * on that schema.\n         * As such, we _know_ that `configuration` has the correct type, it is just not validated\n         * by TypeScript's compiler.\n         */\n        const construct = new this(provider.stack, id, configuration, provider);\n        construct.applyExtensions(configuration.extensions ?? {});\n\n        return construct;\n    }\n\n    abstract outputs?(): Record<string, () => Promise<string | undefined>>;\n\n    abstract extend(): Record<string, CfnResource>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA0C;AAG1C,oBAAgD;AAChD,sBAAsB;AAEtB,mBAA4B;AAErB,MAAe,qBAAqB,kBAAAA,UAA2C;AAAA,EAC1E,gBAAgB,YAAqC;AACzD,UAAM,sBAAsB,KAAK,OAAO;AACxC,YAAI,uBAAQ,UAAU,SAAK,uBAAQ,mBAAmB,GAAG;AACrD;AAAA,IACJ;AACA,WAAO,QAAQ,UAAU,EAAE,QAAQ,CAAC,CAAC,cAAc,eAAe,MAAM;AACpE,UAAI,CAAC,OAAO,KAAK,mBAAmB,EAAE,SAAS,YAAY,GAAG;AAC1D,cAAM,IAAI,aAAAC;AAAA,UACN,0BAA0B,wEAAwE,OAAO;AAAA,YACrG;AAAA,UACJ,EAAE,KAAK,IAAI;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AACA,cAAI,wBAAS,eAAe,GAAG;AAC3B,cAAM,kCAA4C,CAAC;AACnD,mCAAM,eAAe,EAChB,OAAO,CAAC,SAAS,KAAC,uBAAQ,IAAI,CAAC,EAC/B,IAAI,CAAC,SAAS;AACX,iBAAO,KAAK,KAAK,GAAG;AAAA,QACxB,CAAC,EACA,OAAO,CAAC,SAAS;AACd,cACI,gCAAgC;AAAA,YAAK,CAAC,2BAClC,KAAK,WAAW,sBAAsB;AAAA,UAC1C,GACF;AACE,mBAAO;AAAA,UACX;AAEA,gBAAM,mBAAwB,mBAAI,iBAAiB,IAAI;AACvD,gBAAM,4BAAwB,uBAAQ,YAAY;AAClD,cAAI,uBAAuB;AACvB,4CAAgC,KAAK,IAAI;AAEzC,mBAAO;AAAA,UACX;AAEA,gBAAM,uBAAuB,KAAC,wBAAS,YAAY;AAEnD,iBAAO;AAAA,QACX,CAAC,EACA,IAAI,CAAC,SAAS;AACX,8BAAoB,YAAY,EAAE,YAAY,UAAM,mBAAI,iBAAiB,IAAI,CAAC;AAAA,QAClF,CAAC;AAAA,MACT;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,OAAO,OASH,UACA,IACA,eACC;AAtET;AAiFQ,UAAM,YAAY,IAAI,KAAK,SAAS,OAAO,IAAI,eAAe,QAAQ;AACtE,cAAU,iBAAgB,mBAAc,eAAd,YAA4B,CAAC,CAAC;AAExD,WAAO;AAAA,EACX;AAKJ;",
  "names": ["CdkConstruct", "ServerlessError"]
}
