"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerSideWebsite_exports = {};
__export(ServerSideWebsite_exports, {
  ServerSideWebsite: () => ServerSideWebsite
});
module.exports = __toCommonJS(ServerSideWebsite_exports);
var import_aws_s3 = require("aws-cdk-lib/aws-s3");
var import_aws_cloudfront = require("aws-cdk-lib/aws-cloudfront");
var import_aws_cdk_lib = require("aws-cdk-lib");
var import_aws_cloudfront_origins = require("aws-cdk-lib/aws-cloudfront-origins");
var acm = __toESM(require("aws-cdk-lib/aws-certificatemanager"));
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var import_lodash = require("lodash");
var cloudfront = __toESM(require("aws-cdk-lib/aws-cloudfront"));
var import_abstracts = require("../abstracts");
var import_naming = require("../../utils/naming");
var import_s3_sync = require("../../utils/s3-sync");
var import_aws = require("../../classes/aws");
var import_error = __toESM(require("../../utils/error"));
var import_cloudfrontFunctions = require("../../classes/cloudfrontFunctions");
var import_logger = require("../../utils/logger");
const SCHEMA = {
  type: "object",
  properties: {
    type: { const: "server-side-website" },
    apiGateway: { enum: ["http", "rest"] },
    assets: {
      type: "object",
      additionalProperties: { type: "string" },
      propertyNames: {
        pattern: "^/.*$"
      },
      minProperties: 1
    },
    errorPage: { type: "string" },
    domain: {
      anyOf: [
        { type: "string" },
        {
          type: "array",
          items: { type: "string" }
        }
      ]
    },
    redirectToMainDomain: { type: "boolean" },
    certificate: { type: "string" },
    forwardedHeaders: { type: "array", items: { type: "string" } }
  },
  additionalProperties: false
};
const _ServerSideWebsite = class extends import_abstracts.AwsConstruct {
  constructor(scope, id, configuration, provider) {
    super(scope, id);
    this.id = id;
    this.configuration = configuration;
    this.provider = provider;
    if (configuration.domain !== void 0 && configuration.certificate === void 0) {
      throw new import_error.default(
        `Invalid configuration in 'constructs.${id}.certificate': if a domain is configured, then a certificate ARN must be configured as well.`,
        "LIFT_INVALID_CONSTRUCT_CONFIGURATION"
      );
    }
    if (configuration.errorPage !== void 0 && !configuration.errorPage.endsWith(".html")) {
      throw new import_error.default(
        `Invalid configuration in 'constructs.${id}.errorPage': the custom error page must be a static HTML file. '${configuration.errorPage}' does not end with '.html'.`,
        "LIFT_INVALID_CONSTRUCT_CONFIGURATION"
      );
    }
    this.bucket = new import_aws_s3.Bucket(this, "Assets", {
      // Assets are compiled artifacts, we can clear them on serverless remove
      removalPolicy: import_aws_cdk_lib.RemovalPolicy.DESTROY
    });
    const backendOriginPolicy = new class {
      constructor() {
        this.originRequestPolicyId = "b689b0a8-53d0-40ab-baf2-68738e2966ac";
      }
    }();
    const backendCachePolicy = import_aws_cloudfront.CachePolicy.CACHING_DISABLED;
    const apiId = configuration.apiGateway === "rest" ? this.provider.naming.getRestApiLogicalId() : this.provider.naming.getHttpApiLogicalId();
    const apiGatewayDomain = import_aws_cdk_lib.Fn.join(".", [import_aws_cdk_lib.Fn.ref(apiId), `execute-api.${this.provider.region}.amazonaws.com`]);
    this.domains = configuration.domain !== void 0 ? (0, import_lodash.flatten)([configuration.domain]) : void 0;
    const certificate = configuration.certificate !== void 0 ? acm.Certificate.fromCertificateArn(this, "Certificate", configuration.certificate) : void 0;
    this.distribution = new import_aws_cloudfront.Distribution(this, "CDN", {
      comment: `${provider.stackName} ${id} website CDN`,
      defaultBehavior: {
        // Origins are where CloudFront fetches content
        origin: new import_aws_cloudfront_origins.HttpOrigin(apiGatewayDomain, {
          // API Gateway only supports HTTPS
          protocolPolicy: import_aws_cloudfront.OriginProtocolPolicy.HTTPS_ONLY
        }),
        // For a backend app we all all methods
        allowedMethods: import_aws_cloudfront.AllowedMethods.ALLOW_ALL,
        cachePolicy: backendCachePolicy,
        viewerProtocolPolicy: import_aws_cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
        // Forward all values (query strings, headers, and cookies) to the backend app
        // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html#managed-origin-request-policies-list
        originRequestPolicy: backendOriginPolicy,
        functionAssociations: [
          {
            function: this.createRequestFunction(),
            eventType: import_aws_cloudfront.FunctionEventType.VIEWER_REQUEST
          }
        ]
      },
      // All the assets paths are created in there
      additionalBehaviors: this.createCacheBehaviors(this.bucket),
      errorResponses: this.createErrorResponses(),
      // Enable http2 transfer for better performances
      httpVersion: import_aws_cloudfront.HttpVersion.HTTP2,
      certificate,
      domainNames: this.domains
    });
    this.bucketNameOutput = new import_aws_cdk_lib.CfnOutput(this, "AssetsBucketName", {
      description: "Name of the bucket that stores the website assets.",
      value: this.bucket.bucketName
    });
    let websiteDomain = this.getMainCustomDomain();
    if (websiteDomain === void 0) {
      websiteDomain = this.distribution.distributionDomainName;
    }
    this.domainOutput = new import_aws_cdk_lib.CfnOutput(this, "Domain", {
      description: "Website domain name.",
      value: websiteDomain
    });
    this.cnameOutput = new import_aws_cdk_lib.CfnOutput(this, "CloudFrontCName", {
      description: "CloudFront CNAME.",
      value: this.distribution.distributionDomainName
    });
    this.distributionIdOutput = new import_aws_cdk_lib.CfnOutput(this, "DistributionId", {
      description: "ID of the CloudFront distribution.",
      value: this.distribution.distributionId
    });
  }
  outputs() {
    return {
      url: () => this.getUrl(),
      cname: () => this.getCName()
    };
  }
  variables() {
    var _a;
    const domain = (_a = this.getMainCustomDomain()) != null ? _a : this.distribution.distributionDomainName;
    return {
      url: import_aws_cdk_lib.Fn.join("", ["https://", domain]),
      cname: this.distribution.distributionDomainName,
      assetsBucketName: this.bucket.bucketName
    };
  }
  extend() {
    return {
      distribution: this.distribution.node.defaultChild,
      bucket: this.bucket.node.defaultChild
    };
  }
  async postDeploy() {
    await this.uploadAssets();
  }
  async uploadAssetsCommand() {
    (0, import_logger.getUtils)().log(`Deploying the assets for the '${this.id}' website`);
    await this.uploadAssets();
    const domain = await this.getDomain();
    if (domain !== void 0) {
      (0, import_logger.getUtils)().log();
      (0, import_logger.getUtils)().log.success(`Deployed https://${domain}`);
    }
  }
  async uploadAssets() {
    const bucketName = await this.getBucketName();
    if (bucketName === void 0) {
      throw new import_error.default(
        `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`,
        "LIFT_MISSING_STACK_OUTPUT"
      );
    }
    const progress = (0, import_logger.getUtils)().progress;
    let uploadProgress;
    if (progress) {
      uploadProgress = progress.create();
    }
    let invalidate = false;
    for (const [pattern, filePath] of Object.entries(this.getAssetPatterns())) {
      if (!fs.existsSync(filePath)) {
        throw new import_error.default(
          `Error in 'constructs.${this.id}': the file or directory '${filePath}' does not exist`,
          "LIFT_INVALID_CONSTRUCT_CONFIGURATION"
        );
      }
      let s3PathPrefix = path.dirname(pattern);
      if (s3PathPrefix.startsWith("/")) {
        s3PathPrefix = s3PathPrefix.slice(1);
      }
      if (fs.lstatSync(filePath).isDirectory()) {
        if (uploadProgress) {
          uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);
        } else {
          (0, import_logger.getUtils)().log(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);
        }
        const { hasChanges } = await (0, import_s3_sync.s3Sync)({
          aws: this.provider,
          localPath: filePath,
          targetPathPrefix: s3PathPrefix,
          bucketName
        });
        invalidate = invalidate || hasChanges;
      } else {
        const targetKey = path.posix.join(s3PathPrefix, path.basename(filePath));
        if (uploadProgress) {
          uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);
        } else {
          (0, import_logger.getUtils)().log(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);
        }
        await (0, import_s3_sync.s3Put)(this.provider, bucketName, targetKey, fs.readFileSync(filePath));
        invalidate = true;
      }
    }
    if (invalidate) {
      if (uploadProgress) {
        uploadProgress.update(`Clearing CloudFront DNS cache`);
      } else {
        (0, import_logger.getUtils)().log(`Clearing CloudFront DNS cache`);
      }
      await this.clearCDNCache();
    }
    if (uploadProgress) {
      uploadProgress.remove();
    }
  }
  async clearCDNCache() {
    const distributionId = await this.getDistributionId();
    if (distributionId === void 0) {
      return;
    }
    await (0, import_aws.invalidateCloudFrontCache)(this.provider, distributionId);
  }
  async preRemove() {
    const bucketName = await this.getBucketName();
    if (bucketName === void 0) {
      return;
    }
    (0, import_logger.getUtils)().log(
      `Emptying S3 bucket '${bucketName}' for the '${this.id}' website, else CloudFormation will fail (it cannot delete a non-empty bucket)`
    );
    await (0, import_aws.emptyBucket)(this.provider, bucketName);
  }
  async getUrl() {
    const domain = await this.getDomain();
    if (domain === void 0) {
      return void 0;
    }
    return `https://${domain}`;
  }
  async getBucketName() {
    return this.provider.getStackOutput(this.bucketNameOutput);
  }
  async getDomain() {
    return this.provider.getStackOutput(this.domainOutput);
  }
  async getCName() {
    return this.provider.getStackOutput(this.cnameOutput);
  }
  async getDistributionId() {
    return this.provider.getStackOutput(this.distributionIdOutput);
  }
  getMainCustomDomain() {
    if (this.configuration.domain === void 0) {
      return void 0;
    }
    return typeof this.configuration.domain === "string" ? this.configuration.domain : this.configuration.domain[0];
  }
  createCacheBehaviors(bucket) {
    const behaviors = {};
    for (const pattern of Object.keys(this.getAssetPatterns())) {
      if (pattern === "/" || pattern === "/*") {
        throw new import_error.default(
          `Invalid key in 'constructs.${this.id}.assets': '/' and '/*' cannot be routed to assets because the root URL already serves the backend application running in Lambda. You must use a sub-path instead, for example '/assets/*'.`,
          "LIFT_INVALID_CONSTRUCT_CONFIGURATION"
        );
      }
      behaviors[pattern] = {
        // Origins are where CloudFront fetches content
        origin: new import_aws_cloudfront_origins.S3Origin(bucket),
        allowedMethods: import_aws_cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
        // Use the "Managed-CachingOptimized" policy
        // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list
        cachePolicy: import_aws_cloudfront.CachePolicy.CACHING_OPTIMIZED,
        viewerProtocolPolicy: import_aws_cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS
      };
    }
    return behaviors;
  }
  createRequestFunction() {
    let additionalCode = "";
    if (this.configuration.redirectToMainDomain === true) {
      additionalCode += (0, import_cloudfrontFunctions.redirectToMainDomain)(this.domains);
    }
    const code = `function handler(event) {
    var request = event.request;
    request.headers["x-forwarded-host"] = request.headers["host"];${additionalCode}
    return request;
}`;
    const functionName = (0, import_naming.ensureNameMaxLength)(
      `${this.provider.stackName}-${this.provider.region}-${this.id}-request`,
      64
    );
    return new cloudfront.Function(this, "RequestFunction", {
      functionName,
      code: cloudfront.FunctionCode.fromInline(code)
    });
  }
  createErrorResponses() {
    let responsePagePath = void 0;
    if (this.configuration.errorPage !== void 0) {
      responsePagePath = `/${this.getErrorPageFileName()}`;
    }
    return [
      {
        httpStatus: 500,
        // Disable caching of error responses
        ttl: import_aws_cdk_lib.Duration.seconds(0),
        responsePagePath
      },
      {
        httpStatus: 504,
        // Disable caching of error responses
        ttl: import_aws_cdk_lib.Duration.seconds(0),
        responsePagePath
      }
    ];
  }
  getAssetPatterns() {
    var _a;
    const assetPatterns = (_a = this.configuration.assets) != null ? _a : {};
    if (this.configuration.errorPage !== void 0) {
      assetPatterns[`/${this.getErrorPageFileName()}`] = this.configuration.errorPage;
    }
    return assetPatterns;
  }
  getErrorPageFileName() {
    return this.configuration.errorPage !== void 0 ? path.basename(this.configuration.errorPage) : "";
  }
};
let ServerSideWebsite = _ServerSideWebsite;
ServerSideWebsite.type = "server-side-website";
ServerSideWebsite.schema = SCHEMA;
ServerSideWebsite.commands = {
  "assets:upload": {
    usage: "Upload assets directly to S3 without going through a CloudFormation deployment.",
    handler: _ServerSideWebsite.prototype.uploadAssetsCommand
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ServerSideWebsite
});
//# sourceMappingURL=ServerSideWebsite.js.map
