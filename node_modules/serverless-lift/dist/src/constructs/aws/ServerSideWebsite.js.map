{
  "version": 3,
  "sources": ["../../../../src/constructs/aws/ServerSideWebsite.ts"],
  "sourcesContent": ["import type { CfnBucket } from \"aws-cdk-lib/aws-s3\";\nimport { Bucket } from \"aws-cdk-lib/aws-s3\";\nimport type { CfnDistribution, IOriginRequestPolicy } from \"aws-cdk-lib/aws-cloudfront\";\nimport {\n    AllowedMethods,\n    CachePolicy,\n    Distribution,\n    FunctionEventType,\n    HttpVersion,\n    OriginProtocolPolicy,\n    ViewerProtocolPolicy,\n} from \"aws-cdk-lib/aws-cloudfront\";\nimport type { Construct } from \"constructs\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport { CfnOutput, Duration, Fn, RemovalPolicy } from \"aws-cdk-lib\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport { HttpOrigin, S3Origin } from \"aws-cdk-lib/aws-cloudfront-origins\";\nimport * as acm from \"aws-cdk-lib/aws-certificatemanager\";\nimport type { BehaviorOptions, ErrorResponse } from \"aws-cdk-lib/aws-cloudfront/lib/distribution\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\nimport { flatten } from \"lodash\";\nimport * as cloudfront from \"aws-cdk-lib/aws-cloudfront\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { ConstructCommands } from \"@lift/constructs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { ensureNameMaxLength } from \"../../utils/naming\";\nimport { s3Put, s3Sync } from \"../../utils/s3-sync\";\nimport { emptyBucket, invalidateCloudFrontCache } from \"../../classes/aws\";\nimport ServerlessError from \"../../utils/error\";\nimport { redirectToMainDomain } from \"../../classes/cloudfrontFunctions\";\nimport type { Progress } from \"../../utils/logger\";\nimport { getUtils } from \"../../utils/logger\";\n\nconst SCHEMA = {\n    type: \"object\",\n    properties: {\n        type: { const: \"server-side-website\" },\n        apiGateway: { enum: [\"http\", \"rest\"] },\n        assets: {\n            type: \"object\",\n            additionalProperties: { type: \"string\" },\n            propertyNames: {\n                pattern: \"^/.*$\",\n            },\n            minProperties: 1,\n        },\n        errorPage: { type: \"string\" },\n        domain: {\n            anyOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                },\n            ],\n        },\n        redirectToMainDomain: { type: \"boolean\" },\n        certificate: { type: \"string\" },\n        forwardedHeaders: { type: \"array\", items: { type: \"string\" } },\n    },\n    additionalProperties: false,\n} as const;\n\ntype Configuration = FromSchema<typeof SCHEMA>;\n\nexport class ServerSideWebsite extends AwsConstruct {\n    public static type = \"server-side-website\";\n    public static schema = SCHEMA;\n    public static commands: ConstructCommands = {\n        \"assets:upload\": {\n            usage: \"Upload assets directly to S3 without going through a CloudFormation deployment.\",\n            handler: ServerSideWebsite.prototype.uploadAssetsCommand,\n        },\n    };\n\n    private readonly distribution: Distribution;\n    private readonly bucket: Bucket;\n    private readonly domains: string[] | undefined;\n    private readonly bucketNameOutput: CfnOutput;\n    private readonly domainOutput: CfnOutput;\n    private readonly cnameOutput: CfnOutput;\n    private readonly distributionIdOutput: CfnOutput;\n\n    constructor(\n        scope: Construct,\n        private readonly id: string,\n        readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        if (configuration.domain !== undefined && configuration.certificate === undefined) {\n            throw new ServerlessError(\n                `Invalid configuration in 'constructs.${id}.certificate': if a domain is configured, then a certificate ARN must be configured as well.`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n        if (configuration.errorPage !== undefined && !configuration.errorPage.endsWith(\".html\")) {\n            throw new ServerlessError(\n                `Invalid configuration in 'constructs.${id}.errorPage': the custom error page must be a static HTML file. '${configuration.errorPage}' does not end with '.html'.`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        this.bucket = new Bucket(this, \"Assets\", {\n            // Assets are compiled artifacts, we can clear them on serverless remove\n            removalPolicy: RemovalPolicy.DESTROY,\n        });\n\n        // https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html#managed-origin-request-policy-all-viewer-except-host-header\n        // It is not supported by the AWS CDK yet\n        const backendOriginPolicy = new (class implements IOriginRequestPolicy {\n            public readonly originRequestPolicyId = \"b689b0a8-53d0-40ab-baf2-68738e2966ac\";\n        })();\n        const backendCachePolicy = CachePolicy.CACHING_DISABLED;\n\n        const apiId =\n            configuration.apiGateway === \"rest\"\n                ? this.provider.naming.getRestApiLogicalId()\n                : this.provider.naming.getHttpApiLogicalId();\n        const apiGatewayDomain = Fn.join(\".\", [Fn.ref(apiId), `execute-api.${this.provider.region}.amazonaws.com`]);\n\n        // Cast the domains to an array\n        this.domains = configuration.domain !== undefined ? flatten([configuration.domain]) : undefined;\n        const certificate =\n            configuration.certificate !== undefined\n                ? acm.Certificate.fromCertificateArn(this, \"Certificate\", configuration.certificate)\n                : undefined;\n\n        this.distribution = new Distribution(this, \"CDN\", {\n            comment: `${provider.stackName} ${id} website CDN`,\n            defaultBehavior: {\n                // Origins are where CloudFront fetches content\n                origin: new HttpOrigin(apiGatewayDomain, {\n                    // API Gateway only supports HTTPS\n                    protocolPolicy: OriginProtocolPolicy.HTTPS_ONLY,\n                }),\n                // For a backend app we all all methods\n                allowedMethods: AllowedMethods.ALLOW_ALL,\n                cachePolicy: backendCachePolicy,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n                // Forward all values (query strings, headers, and cookies) to the backend app\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html#managed-origin-request-policies-list\n                originRequestPolicy: backendOriginPolicy,\n                functionAssociations: [\n                    {\n                        function: this.createRequestFunction(),\n                        eventType: FunctionEventType.VIEWER_REQUEST,\n                    },\n                ],\n            },\n            // All the assets paths are created in there\n            additionalBehaviors: this.createCacheBehaviors(this.bucket),\n            errorResponses: this.createErrorResponses(),\n            // Enable http2 transfer for better performances\n            httpVersion: HttpVersion.HTTP2,\n            certificate: certificate,\n            domainNames: this.domains,\n        });\n\n        // CloudFormation outputs\n        this.bucketNameOutput = new CfnOutput(this, \"AssetsBucketName\", {\n            description: \"Name of the bucket that stores the website assets.\",\n            value: this.bucket.bucketName,\n        });\n        let websiteDomain = this.getMainCustomDomain();\n        if (websiteDomain === undefined) {\n            // Fallback on the CloudFront domain\n            websiteDomain = this.distribution.distributionDomainName;\n        }\n        this.domainOutput = new CfnOutput(this, \"Domain\", {\n            description: \"Website domain name.\",\n            value: websiteDomain,\n        });\n        this.cnameOutput = new CfnOutput(this, \"CloudFrontCName\", {\n            description: \"CloudFront CNAME.\",\n            value: this.distribution.distributionDomainName,\n        });\n        this.distributionIdOutput = new CfnOutput(this, \"DistributionId\", {\n            description: \"ID of the CloudFront distribution.\",\n            value: this.distribution.distributionId,\n        });\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            url: () => this.getUrl(),\n            cname: () => this.getCName(),\n        };\n    }\n\n    variables(): Record<string, unknown> {\n        const domain = this.getMainCustomDomain() ?? this.distribution.distributionDomainName;\n\n        return {\n            url: Fn.join(\"\", [\"https://\", domain]),\n            cname: this.distribution.distributionDomainName,\n            assetsBucketName: this.bucket.bucketName,\n        };\n    }\n\n    extend(): Record<string, CfnResource> {\n        return {\n            distribution: this.distribution.node.defaultChild as CfnDistribution,\n            bucket: this.bucket.node.defaultChild as CfnBucket,\n        };\n    }\n\n    async postDeploy(): Promise<void> {\n        await this.uploadAssets();\n    }\n\n    async uploadAssetsCommand(): Promise<void> {\n        getUtils().log(`Deploying the assets for the '${this.id}' website`);\n\n        await this.uploadAssets();\n\n        const domain = await this.getDomain();\n        if (domain !== undefined) {\n            getUtils().log();\n            getUtils().log.success(`Deployed https://${domain}`);\n        }\n    }\n\n    async uploadAssets(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            throw new ServerlessError(\n                `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`,\n                \"LIFT_MISSING_STACK_OUTPUT\"\n            );\n        }\n\n        const progress = getUtils().progress;\n        let uploadProgress: Progress | undefined;\n        if (progress) {\n            uploadProgress = progress.create();\n        }\n\n        let invalidate = false;\n        for (const [pattern, filePath] of Object.entries(this.getAssetPatterns())) {\n            if (!fs.existsSync(filePath)) {\n                throw new ServerlessError(\n                    `Error in 'constructs.${this.id}': the file or directory '${filePath}' does not exist`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            let s3PathPrefix: string = path.dirname(pattern);\n            if (s3PathPrefix.startsWith(\"/\")) {\n                s3PathPrefix = s3PathPrefix.slice(1);\n            }\n\n            if (fs.lstatSync(filePath).isDirectory()) {\n                // Directory\n                if (uploadProgress) {\n                    uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);\n                } else {\n                    getUtils().log(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);\n                }\n                const { hasChanges } = await s3Sync({\n                    aws: this.provider,\n                    localPath: filePath,\n                    targetPathPrefix: s3PathPrefix,\n                    bucketName,\n                });\n                invalidate = invalidate || hasChanges;\n            } else {\n                // File\n                const targetKey = path.posix.join(s3PathPrefix, path.basename(filePath));\n                if (uploadProgress) {\n                    uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);\n                } else {\n                    getUtils().log(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);\n                }\n                await s3Put(this.provider, bucketName, targetKey, fs.readFileSync(filePath));\n                invalidate = true;\n            }\n        }\n        if (invalidate) {\n            if (uploadProgress) {\n                uploadProgress.update(`Clearing CloudFront DNS cache`);\n            } else {\n                getUtils().log(`Clearing CloudFront DNS cache`);\n            }\n            await this.clearCDNCache();\n        }\n\n        if (uploadProgress) {\n            uploadProgress.remove();\n        }\n    }\n\n    private async clearCDNCache(): Promise<void> {\n        const distributionId = await this.getDistributionId();\n        if (distributionId === undefined) {\n            return;\n        }\n        await invalidateCloudFrontCache(this.provider, distributionId);\n    }\n\n    async preRemove(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            // No bucket found => nothing to delete!\n            return;\n        }\n\n        getUtils().log(\n            `Emptying S3 bucket '${bucketName}' for the '${this.id}' website, else CloudFormation will fail (it cannot delete a non-empty bucket)`\n        );\n        await emptyBucket(this.provider, bucketName);\n    }\n\n    async getUrl(): Promise<string | undefined> {\n        const domain = await this.getDomain();\n        if (domain === undefined) {\n            return undefined;\n        }\n\n        return `https://${domain}`;\n    }\n\n    async getBucketName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.bucketNameOutput);\n    }\n\n    async getDomain(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.domainOutput);\n    }\n\n    async getCName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.cnameOutput);\n    }\n\n    async getDistributionId(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.distributionIdOutput);\n    }\n\n    getMainCustomDomain(): string | undefined {\n        if (this.configuration.domain === undefined) {\n            return undefined;\n        }\n\n        // In case of multiple domains, we take the first one\n        return typeof this.configuration.domain === \"string\" ? this.configuration.domain : this.configuration.domain[0];\n    }\n\n    private createCacheBehaviors(bucket: Bucket): Record<string, BehaviorOptions> {\n        const behaviors: Record<string, BehaviorOptions> = {};\n        for (const pattern of Object.keys(this.getAssetPatterns())) {\n            if (pattern === \"/\" || pattern === \"/*\") {\n                throw new ServerlessError(\n                    `Invalid key in 'constructs.${this.id}.assets': '/' and '/*' cannot be routed to assets because the root URL already serves the backend application running in Lambda. You must use a sub-path instead, for example '/assets/*'.`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            behaviors[pattern] = {\n                // Origins are where CloudFront fetches content\n                origin: new S3Origin(bucket),\n                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,\n                // Use the \"Managed-CachingOptimized\" policy\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list\n                cachePolicy: CachePolicy.CACHING_OPTIMIZED,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n            };\n        }\n\n        return behaviors;\n    }\n\n    private createRequestFunction(): cloudfront.Function {\n        let additionalCode = \"\";\n\n        if (this.configuration.redirectToMainDomain === true) {\n            additionalCode += redirectToMainDomain(this.domains);\n        }\n\n        /**\n         * CloudFront function that forwards the real `Host` header into `X-Forwarded-Host`\n         *\n         * CloudFront does not forward the original `Host` header. We use this\n         * to forward the website domain name to the backend app via the `X-Forwarded-Host` header.\n         * Learn more: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host\n         */\n        const code = `function handler(event) {\n    var request = event.request;\n    request.headers[\"x-forwarded-host\"] = request.headers[\"host\"];${additionalCode}\n    return request;\n}`;\n\n        const functionName = ensureNameMaxLength(\n            `${this.provider.stackName}-${this.provider.region}-${this.id}-request`,\n            64\n        );\n\n        return new cloudfront.Function(this, \"RequestFunction\", {\n            functionName,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n\n    private createErrorResponses(): ErrorResponse[] {\n        let responsePagePath = undefined;\n        if (this.configuration.errorPage !== undefined) {\n            responsePagePath = `/${this.getErrorPageFileName()}`;\n        }\n\n        return [\n            {\n                httpStatus: 500,\n                // Disable caching of error responses\n                ttl: Duration.seconds(0),\n                responsePagePath,\n            },\n            {\n                httpStatus: 504,\n                // Disable caching of error responses\n                ttl: Duration.seconds(0),\n                responsePagePath,\n            },\n        ];\n    }\n\n    private getAssetPatterns(): Record<string, string> {\n        const assetPatterns = this.configuration.assets ?? {};\n        // If a custom error page is provided, we upload it to S3\n        if (this.configuration.errorPage !== undefined) {\n            assetPatterns[`/${this.getErrorPageFileName()}`] = this.configuration.errorPage;\n        }\n\n        return assetPatterns;\n    }\n\n    private getErrorPageFileName(): string {\n        return this.configuration.errorPage !== undefined ? path.basename(this.configuration.errorPage) : \"\";\n    }\n}\n"],
  "mappings": "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",
  "names": ["ServerlessError"]
}
