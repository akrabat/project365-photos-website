{
  "version": 3,
  "sources": ["../../../../src/constructs/aws/Webhook.ts"],
  "sourcesContent": ["import type { Construct as CdkConstruct } from \"constructs\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport { CfnOutput, Fn } from \"aws-cdk-lib\";\nimport { CfnAuthorizer, CfnIntegration, CfnRoute } from \"aws-cdk-lib/aws-apigatewayv2\";\nimport { HttpApi } from \"@aws-cdk/aws-apigatewayv2-alpha\";\nimport { Function } from \"aws-cdk-lib/aws-lambda\";\nimport type { CfnEventBus } from \"aws-cdk-lib/aws-events\";\nimport { EventBus } from \"aws-cdk-lib/aws-events\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport { PolicyDocument, PolicyStatement, Role, ServicePrincipal } from \"aws-cdk-lib/aws-iam\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { CfnHttpApi } from \"aws-cdk-lib/aws-sam\";\nimport ServerlessError from \"../../utils/error\";\n\nconst WEBHOOK_DEFINITION = {\n    type: \"object\",\n    properties: {\n        type: { const: \"webhook\" },\n        authorizer: {\n            type: \"object\",\n            properties: {\n                handler: { type: \"string\" },\n            },\n            required: [\"handler\"],\n            additionalProperties: true,\n        },\n        insecure: { type: \"boolean\" },\n        path: { type: \"string\" },\n        eventType: { type: \"string\" },\n    },\n    required: [\"path\"],\n    additionalProperties: false,\n} as const;\nconst WEBHOOK_DEFAULTS = {\n    insecure: false,\n};\n\ntype Configuration = FromSchema<typeof WEBHOOK_DEFINITION>;\n\nexport class Webhook extends AwsConstruct {\n    public static type = \"webhook\";\n    public static schema = WEBHOOK_DEFINITION;\n\n    private readonly api: HttpApi;\n    private readonly bus: EventBus;\n    private readonly apiEndpointOutput: CfnOutput;\n    private readonly endpointPathOutput: CfnOutput;\n\n    constructor(\n        scope: CdkConstruct,\n        private readonly id: string,\n        private readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        this.api = new HttpApi(this, \"HttpApi\");\n        this.apiEndpointOutput = new CfnOutput(this, \"HttpApiEndpoint\", {\n            value: this.api.apiEndpoint,\n        });\n        this.bus = new EventBus(this, \"Bus\");\n        const apiGatewayRole = new Role(this, \"ApiGatewayRole\", {\n            assumedBy: new ServicePrincipal(\"apigateway.amazonaws.com\"),\n            inlinePolicies: {\n                EventBridge: new PolicyDocument({\n                    statements: [\n                        new PolicyStatement({\n                            actions: [\"events:PutEvents\"],\n                            resources: [this.bus.eventBusArn],\n                        }),\n                    ],\n                }),\n            },\n        });\n\n        const resolvedConfiguration = Object.assign({}, WEBHOOK_DEFAULTS, configuration);\n        if (resolvedConfiguration.insecure && resolvedConfiguration.authorizer !== undefined) {\n            throw new ServerlessError(\n                `Webhook ${id} is specified as insecure, however an authorizer is configured for this webhook. ` +\n                    \"Either declare this webhook as secure by removing `insecure: true` property (recommended), \" +\n                    \"or specify the webhook as insecure and remove the authorizer property altogether.\\n\" +\n                    \"See https://github.com/getlift/lift/blob/master/docs/webhook.md#authorizer\",\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n        if (!resolvedConfiguration.insecure && resolvedConfiguration.authorizer === undefined) {\n            throw new ServerlessError(\n                `Webhook ${id} is specified as secure, however no authorizer is configured for this webhook. ` +\n                    \"Please provide an authorizer property for this webhook (recommended), \" +\n                    \"or specify the webhook as insecure by adding `insecure: true` property.\\n\" +\n                    \"See https://github.com/getlift/lift/blob/master/docs/webhook.md#authorizer\",\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        const eventBridgeIntegration = new CfnIntegration(this, \"Integration\", {\n            apiId: this.api.apiId,\n            connectionType: \"INTERNET\",\n            credentialsArn: apiGatewayRole.roleArn,\n            integrationSubtype: \"EventBridge-PutEvents\",\n            integrationType: \"AWS_PROXY\",\n            payloadFormatVersion: \"1.0\",\n            requestParameters: {\n                DetailType: resolvedConfiguration.eventType ?? \"Webhook\",\n                Detail: \"$request.body\",\n                Source: id,\n                EventBusName: this.bus.eventBusName,\n            },\n        });\n        const route = new CfnRoute(this, \"Route\", {\n            apiId: this.api.apiId,\n            routeKey: `POST ${resolvedConfiguration.path}`,\n            target: Fn.join(\"/\", [\"integrations\", eventBridgeIntegration.ref]),\n            authorizationType: \"NONE\",\n        });\n\n        if (!resolvedConfiguration.insecure) {\n            const lambda = Function.fromFunctionArn(\n                this,\n                \"LambdaAuthorizer\",\n                Fn.getAtt(provider.naming.getLambdaLogicalId(`${id}Authorizer`), \"Arn\").toString()\n            );\n            lambda.grantInvoke(apiGatewayRole);\n            const authorizer = new CfnAuthorizer(this, \"Authorizer\", {\n                apiId: this.api.apiId,\n                authorizerPayloadFormatVersion: \"2.0\",\n                authorizerType: \"REQUEST\",\n                name: `${id}-authorizer`,\n                enableSimpleResponses: true,\n                authorizerUri: Fn.join(\"/\", [\n                    `arn:aws:apigateway:${this.provider.region}:lambda:path/2015-03-31/functions`,\n                    lambda.functionArn,\n                    \"invocations\",\n                ]),\n                authorizerCredentialsArn: apiGatewayRole.roleArn,\n            });\n            route.authorizerId = authorizer.ref;\n            route.authorizationType = \"CUSTOM\";\n        }\n\n        this.endpointPathOutput = new CfnOutput(this, \"Endpoint\", {\n            value: route.routeKey,\n        });\n\n        this.appendFunctions();\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            httpMethod: () => this.getHttpMethod(),\n            url: () => this.getUrl(),\n        };\n    }\n\n    variables(): Record<string, unknown> {\n        return {\n            busName: this.bus.eventBusName,\n        };\n    }\n\n    extend(): Record<string, CfnResource> {\n        return {\n            api: this.api.node.defaultChild as CfnHttpApi,\n            bus: this.bus.node.defaultChild as CfnEventBus,\n        };\n    }\n\n    private appendFunctions(): void {\n        const resolvedWebhookConfiguration = Object.assign({}, WEBHOOK_DEFAULTS, this.configuration);\n        if (resolvedWebhookConfiguration.insecure) {\n            return;\n        }\n        this.provider.addFunction(`${this.id}Authorizer`, resolvedWebhookConfiguration.authorizer);\n    }\n\n    private async getEndpointPath(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.endpointPathOutput);\n    }\n\n    private async getHttpMethod(): Promise<string | undefined> {\n        const endpointPath = await this.getEndpointPath();\n        if (endpointPath === undefined) {\n            return undefined;\n        }\n        const [httpMethod] = endpointPath.split(\" \");\n\n        return httpMethod;\n    }\n\n    private async getUrl(): Promise<string | undefined> {\n        const apiEndpoint = await this.provider.getStackOutput(this.apiEndpointOutput);\n        if (apiEndpoint === undefined) {\n            return undefined;\n        }\n        const endpointPath = await this.getEndpointPath();\n        if (endpointPath === undefined) {\n            return undefined;\n        }\n        const [, path] = endpointPath.split(\" \");\n\n        return apiEndpoint + path;\n    }\n}\n"],
  "mappings": "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",
  "names": ["ServerlessError"]
}
