{
  "version": 3,
  "sources": ["../../../../../src/constructs/aws/abstracts/StaticWebsiteAbstract.ts"],
  "sourcesContent": ["import * as acm from \"aws-cdk-lib/aws-certificatemanager\";\nimport * as cloudfront from \"aws-cdk-lib/aws-cloudfront\";\nimport type { CfnDistribution, ErrorResponse } from \"aws-cdk-lib/aws-cloudfront\";\nimport {\n    AllowedMethods,\n    CachePolicy,\n    Distribution,\n    FunctionEventType,\n    HttpVersion,\n    ViewerProtocolPolicy,\n} from \"aws-cdk-lib/aws-cloudfront\";\nimport { S3Origin } from \"aws-cdk-lib/aws-cloudfront-origins\";\nimport type { BucketProps, CfnBucket } from \"aws-cdk-lib/aws-s3\";\nimport { Bucket } from \"aws-cdk-lib/aws-s3\";\nimport type { Construct as CdkConstruct } from \"constructs\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport { Duration, RemovalPolicy } from \"aws-cdk-lib\";\nimport { CfnOutput } from \"aws-cdk-lib\";\nimport type { ConstructCommands } from \"@lift/constructs\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport chalk from \"chalk\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport { flatten } from \"lodash\";\nimport { emptyBucket, invalidateCloudFrontCache } from \"../../../classes/aws\";\nimport ServerlessError from \"../../../utils/error\";\nimport type { Progress } from \"../../../utils/logger\";\nimport { getUtils } from \"../../../utils/logger\";\nimport { ensureNameMaxLength } from \"../../../utils/naming\";\nimport { s3Sync } from \"../../../utils/s3-sync\";\n\nexport const COMMON_STATIC_WEBSITE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        path: { type: \"string\" },\n        domain: {\n            anyOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                },\n            ],\n        },\n        certificate: { type: \"string\" },\n        security: {\n            type: \"object\",\n            properties: {\n                allowIframe: { type: \"boolean\" },\n            },\n            additionalProperties: false,\n        },\n        errorPage: { type: \"string\" },\n        redirectToMainDomain: { type: \"boolean\" },\n    },\n    additionalProperties: false,\n    required: [\"path\"],\n} as const;\n\nexport type CommonStaticWebsiteConfiguration = FromSchema<typeof COMMON_STATIC_WEBSITE_DEFINITION>;\n\nexport abstract class StaticWebsiteAbstract extends AwsConstruct {\n    public static commands: ConstructCommands = {\n        upload: {\n            usage: \"Upload files directly to S3 without going through a CloudFormation deployment.\",\n            handler: StaticWebsiteAbstract.prototype.uploadWebsiteCommand,\n        },\n    };\n\n    protected readonly distribution: Distribution;\n    protected readonly bucket: Bucket;\n    protected readonly domains: string[] | undefined;\n    private readonly bucketNameOutput: CfnOutput;\n    private readonly domainOutput: CfnOutput;\n    private readonly cnameOutput: CfnOutput;\n    private readonly distributionIdOutput: CfnOutput;\n\n    constructor(\n        scope: CdkConstruct,\n        protected readonly id: string,\n        protected readonly configuration: CommonStaticWebsiteConfiguration,\n        protected readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        const bucketProps = this.getBucketProps();\n\n        this.bucket = new Bucket(this, \"Bucket\", bucketProps);\n\n        // Cast the domains to an array\n        // if configuration.domain is an empty array or an empty string, ignore it\n        this.domains =\n            configuration.domain !== undefined && configuration.domain.length > 0\n                ? flatten([configuration.domain])\n                : undefined;\n        // if configuration.certificate is an empty string, ignore it\n        const certificate =\n            configuration.certificate !== undefined && configuration.certificate !== \"\"\n                ? acm.Certificate.fromCertificateArn(this, \"Certificate\", configuration.certificate)\n                : undefined;\n\n        if (this.domains !== undefined && certificate === undefined) {\n            throw new ServerlessError(\n                `Invalid configuration for the static website '${id}': if a domain is configured, then a certificate ARN must be configured in the 'certificate' option.\\n` +\n                    \"See https://github.com/getlift/lift/blob/master/docs/static-website.md#custom-domain\",\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        const functionAssociations = [\n            {\n                function: this.createResponseFunction(),\n                eventType: FunctionEventType.VIEWER_RESPONSE,\n            },\n        ];\n\n        this.distribution = new Distribution(this, \"CDN\", {\n            comment: `${provider.stackName} ${id} website CDN`,\n            // Send all page requests to index.html\n            defaultRootObject: \"index.html\",\n            defaultBehavior: {\n                // Origins are where CloudFront fetches content\n                origin: new S3Origin(this.bucket),\n                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,\n                // Use the \"Managed-CachingOptimized\" policy\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list\n                cachePolicy: CachePolicy.CACHING_OPTIMIZED,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n                functionAssociations: functionAssociations,\n            },\n            errorResponses: [this.errorResponse()],\n            // Enable http2 transfer for better performances\n            httpVersion: HttpVersion.HTTP2,\n            certificate: certificate,\n            domainNames: this.domains,\n        });\n\n        // CloudFormation outputs\n        this.bucketNameOutput = new CfnOutput(this, \"BucketName\", {\n            description: \"Name of the bucket that stores the static website.\",\n            value: this.bucket.bucketName,\n        });\n        let websiteDomain: string = this.distribution.distributionDomainName;\n        if (this.domains !== undefined) {\n            // In case of multiple domains, we take the first one\n            websiteDomain = this.domains[0];\n        }\n        this.domainOutput = new CfnOutput(this, \"Domain\", {\n            description: \"Website domain name.\",\n            value: websiteDomain,\n        });\n        this.cnameOutput = new CfnOutput(this, \"CloudFrontCName\", {\n            description: \"CloudFront CNAME.\",\n            value: this.distribution.distributionDomainName,\n        });\n        this.distributionIdOutput = new CfnOutput(this, \"DistributionId\", {\n            description: \"ID of the CloudFront distribution.\",\n            value: this.distribution.distributionId,\n        });\n    }\n\n    variables(): Record<string, unknown> {\n        return {\n            cname: this.distribution.distributionDomainName,\n            assetsBucketName: this.bucket.bucketName,\n        };\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            url: () => this.getUrl(),\n            cname: () => this.getCName(),\n        };\n    }\n\n    extend(): Record<string, CfnResource> {\n        return {\n            distribution: this.distribution.node.defaultChild as CfnDistribution,\n            bucket: this.bucket.node.defaultChild as CfnBucket,\n        };\n    }\n\n    async postDeploy(): Promise<void> {\n        await this.uploadWebsite();\n    }\n\n    async uploadWebsiteCommand(): Promise<void> {\n        getUtils().log(`Deploying the static website '${this.id}'`);\n\n        const fileChangeCount = await this.uploadWebsite();\n\n        const domain = await this.getDomain();\n        if (domain !== undefined) {\n            getUtils().log();\n            getUtils().log.success(`Deployed https://${domain} ${chalk.gray(`(${fileChangeCount} files changed)`)}`);\n        }\n    }\n\n    private async uploadWebsite(): Promise<number> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            throw new ServerlessError(\n                `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`,\n                \"LIFT_MISSING_STACK_OUTPUT\"\n            );\n        }\n\n        const progress = getUtils().progress;\n        let uploadProgress: Progress | undefined;\n        if (progress) {\n            uploadProgress = progress.create({\n                message: `Uploading directory '${this.configuration.path}' to bucket '${bucketName}'`,\n            });\n            getUtils().log.verbose(`Uploading directory '${this.configuration.path}' to bucket '${bucketName}'`);\n        } else {\n            getUtils().log(`Uploading directory '${this.configuration.path}' to bucket '${bucketName}'`);\n        }\n        const { hasChanges, fileChangeCount } = await s3Sync({\n            aws: this.provider,\n            localPath: this.configuration.path,\n            bucketName,\n        });\n        if (hasChanges) {\n            if (uploadProgress) {\n                uploadProgress.update(`Clearing CloudFront DNS cache`);\n            } else {\n                getUtils().log(`Clearing CloudFront DNS cache`);\n            }\n            await this.clearCDNCache();\n        }\n\n        if (uploadProgress) {\n            uploadProgress.remove();\n        }\n\n        return fileChangeCount;\n    }\n\n    private async clearCDNCache(): Promise<void> {\n        const distributionId = await this.getDistributionId();\n        if (distributionId === undefined) {\n            return;\n        }\n        await invalidateCloudFrontCache(this.provider, distributionId);\n    }\n\n    async preRemove(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            // No bucket found => nothing to delete!\n            return;\n        }\n\n        getUtils().log(\n            `Emptying S3 bucket '${bucketName}' for the '${this.id}' static website, else CloudFormation will fail (it cannot delete a non-empty bucket)`\n        );\n        await emptyBucket(this.provider, bucketName);\n    }\n\n    async getUrl(): Promise<string | undefined> {\n        const domain = await this.getDomain();\n        if (domain === undefined) {\n            return undefined;\n        }\n\n        return `https://${domain}`;\n    }\n\n    async getBucketName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.bucketNameOutput);\n    }\n\n    async getDomain(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.domainOutput);\n    }\n\n    async getCName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.cnameOutput);\n    }\n\n    async getDistributionId(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.distributionIdOutput);\n    }\n\n    errorPath(): string | undefined {\n        if (this.configuration.errorPage !== undefined) {\n            let errorPath = this.configuration.errorPage;\n            if (errorPath.startsWith(\"./\") || errorPath.startsWith(\"../\")) {\n                throw new ServerlessError(\n                    `The 'errorPage' option of the '${this.id}' static website cannot start with './' or '../'. ` +\n                        `(it cannot be a relative path).`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            if (!errorPath.startsWith(\"/\")) {\n                errorPath = `/${errorPath}`;\n            }\n\n            return errorPath;\n        }\n    }\n\n    private errorResponse(): ErrorResponse {\n        const errorPath = this.errorPath();\n\n        // Custom error page\n        if (errorPath !== undefined) {\n            return {\n                httpStatus: 404,\n                ttl: Duration.seconds(0),\n                responseHttpStatus: 404,\n                responsePagePath: errorPath,\n            };\n        }\n\n        /**\n         * The default behavior is optimized for SPA: all unknown URLs are served\n         * by index.html so that routing can be done client-side.\n         */\n        return {\n            httpStatus: 404,\n            ttl: Duration.seconds(0),\n            responseHttpStatus: 200,\n            responsePagePath: \"/index.html\",\n        };\n    }\n\n    private createResponseFunction(): cloudfront.Function {\n        const securityHeaders: Record<string, { value: string }> = {\n            \"x-frame-options\": { value: \"SAMEORIGIN\" },\n            \"x-content-type-options\": { value: \"nosniff\" },\n            \"x-xss-protection\": { value: \"1; mode=block\" },\n            \"strict-transport-security\": { value: \"max-age=63072000\" },\n        };\n        if (this.configuration.security?.allowIframe === true) {\n            delete securityHeaders[\"x-frame-options\"];\n        }\n        const jsonHeaders = JSON.stringify(securityHeaders, undefined, 4);\n        /**\n         * CloudFront function that manipulates the HTTP responses to add security headers.\n         */\n        const code = `function handler(event) {\n    var response = event.response;\n    response.headers = Object.assign({}, ${jsonHeaders}, response.headers);\n    return response;\n}`;\n\n        const functionName = ensureNameMaxLength(\n            `${this.provider.stackName}-${this.provider.region}-${this.id}-response`,\n            64\n        );\n\n        return new cloudfront.Function(this, \"ResponseFunction\", {\n            functionName,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n\n    getBucketProps(): BucketProps {\n        return {\n            // For a static website, the content is code that should be versioned elsewhere\n            removalPolicy: RemovalPolicy.DESTROY,\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_aws_cdk_lib", "ServerlessError", "chalk"]
}
