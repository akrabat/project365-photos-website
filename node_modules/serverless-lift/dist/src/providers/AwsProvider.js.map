{
  "version": 3,
  "sources": ["../../../src/providers/AwsProvider.ts"],
  "sourcesContent": ["import type { CfnOutput } from \"aws-cdk-lib\";\nimport { App, DefaultStackSynthesizer, Stack } from \"aws-cdk-lib\";\nimport { get, merge } from \"lodash\";\nimport type { AwsCfInstruction, AwsLambdaVpcConfig } from \"@serverless/typescript\";\nimport type { ProviderInterface } from \"@lift/providers\";\nimport type { ConstructInterface, StaticConstructInterface } from \"@lift/constructs\";\nimport {\n    DatabaseDynamoDBSingleTable,\n    Queue,\n    ServerSideWebsite,\n    SinglePageApp,\n    StaticWebsite,\n    Storage,\n    Vpc,\n    Webhook,\n} from \"@lift/constructs/aws\";\nimport { getStackOutput } from \"../CloudFormation\";\nimport type { CloudformationTemplate, Provider as LegacyAwsProvider, Serverless } from \"../types/serverless\";\nimport { awsRequest } from \"../classes/aws\";\nimport ServerlessError from \"../utils/error\";\n\nconst AWS_DEFINITION = {\n    type: \"object\",\n    properties: {},\n    additionalProperties: false,\n} as const;\n\nexport class AwsProvider implements ProviderInterface {\n    public static type = \"aws\";\n    public static schema = AWS_DEFINITION;\n    private static readonly constructClasses: Record<string, StaticConstructInterface> = {};\n\n    static registerConstructs(...constructClasses: StaticConstructInterface[]): void {\n        for (const constructClass of constructClasses) {\n            if (constructClass.type in this.constructClasses) {\n                throw new ServerlessError(\n                    `The construct type '${constructClass.type}' was registered twice`,\n                    \"LIFT_CONSTRUCT_TYPE_CONFLICT\"\n                );\n            }\n            this.constructClasses[constructClass.type] = constructClass;\n        }\n    }\n\n    static getConstructClass(type: string): StaticConstructInterface | undefined {\n        return this.constructClasses[type];\n    }\n\n    static getAllConstructClasses(): StaticConstructInterface[] {\n        return Object.values(this.constructClasses);\n    }\n\n    static create(serverless: Serverless): ProviderInterface {\n        return new this(serverless);\n    }\n\n    private readonly app: App;\n    public readonly stack: Stack;\n    public readonly region: string;\n    public readonly stackName: string;\n    private readonly legacyProvider: LegacyAwsProvider;\n    public naming: {\n        getStackName: () => string;\n        getLambdaLogicalId: (functionName: string) => string;\n        getRestApiLogicalId: () => string;\n        getHttpApiLogicalId: () => string;\n    };\n\n    constructor(private readonly serverless: Serverless) {\n        this.stackName = serverless.getProvider(\"aws\").naming.getStackName();\n        this.app = new App();\n        this.stack = new Stack(this.app, undefined, {\n            synthesizer: new DefaultStackSynthesizer({\n                generateBootstrapVersionRule: false,\n            }),\n        });\n        this.legacyProvider = serverless.getProvider(\"aws\");\n        this.naming = this.legacyProvider.naming;\n        this.region = serverless.getProvider(\"aws\").getRegion();\n        serverless.stack = this.stack;\n    }\n\n    createConstruct(type: string, id: string): ConstructInterface {\n        const Construct = AwsProvider.getConstructClass(type);\n        if (Construct === undefined) {\n            throw new ServerlessError(\n                `The construct '${id}' has an unknown type '${type}'\\n` +\n                    \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                \"LIFT_UNKNOWN_CONSTRUCT_TYPE\"\n            );\n        }\n        const configuration = get(this.serverless.configurationInput.constructs, id, {});\n\n        return Construct.create(this, id, configuration);\n    }\n\n    addFunction(functionName: string, functionConfig: unknown): void {\n        if (!this.serverless.configurationInput.functions) {\n            // If serverless.yml does not contain any functions, bootstrapping a new empty functions config\n            this.serverless.configurationInput.functions = {};\n        }\n\n        merge(this.serverless.service.functions, {\n            [functionName]: functionConfig,\n        });\n        /**\n         * We must manually call `setFunctionNames()`: this is a function that normalizes functions.\n         * This function is called by the Framework, but we have to call it again because we add new\n         * functions after this function has already run. So our new function (that we add here)\n         * will not have been normalized.\n         */\n        this.serverless.service.setFunctionNames(this.serverless.processedInput.options);\n    }\n\n    /**\n     * @internal\n     */\n    setVpcConfig(securityGroups: AwsCfInstruction[], subnets: AwsCfInstruction[]): void {\n        if (this.getVpcConfig() !== null) {\n            throw new ServerlessError(\n                \"Can't register more than one VPC.\\n\" +\n                    'Either you have several \"vpc\" constructs \\n' +\n                    'or you already defined \"provider.vpc\" in serverless.yml',\n                \"LIFT_ONLY_ONE_VPC\"\n            );\n        }\n\n        this.serverless.service.provider.vpc = {\n            securityGroupIds: securityGroups, // TODO : merge with existing groups ?\n            subnetIds: subnets,\n        };\n    }\n\n    /**\n     * This function can be used by other constructs to reference\n     * global subnets or security groups in their resources\n     *\n     * @internal\n     */\n    getVpcConfig(): AwsLambdaVpcConfig | null {\n        return this.serverless.service.provider.vpc ?? null;\n    }\n\n    /**\n     * Resolves the value of a CloudFormation stack output.\n     */\n    async getStackOutput(output: CfnOutput): Promise<string | undefined> {\n        return getStackOutput(this, output);\n    }\n\n    /**\n     * Send a request to the AWS API.\n     */\n    request<Input, Output>(service: string, method: string, params: Input): Promise<Output> {\n        return awsRequest<Input, Output>(params, service, method, this.legacyProvider);\n    }\n\n    appendCloudformationResources(): void {\n        merge(this.serverless.service, {\n            resources: this.app.synth().getStackByName(this.stack.stackName).template as CloudformationTemplate,\n        });\n    }\n}\n\n/**\n * This is representative of a possible public API to register constructs. How it would work:\n * - 3rd party developers create a custom construct\n * - they also create a plugin that calls:\n *       AwsProvider.registerConstructs(Foo, Bar);\n *  If they use TypeScript, `registerConstructs()` will validate that the construct class\n *  implements both static fields (type, schema, create(), \u2026) and non-static fields (outputs(), references(), \u2026).\n */\nAwsProvider.registerConstructs(\n    Storage,\n    Queue,\n    Webhook,\n    SinglePageApp,\n    StaticWebsite,\n    Vpc,\n    DatabaseDynamoDBSingleTable,\n    ServerSideWebsite\n);\n"],
  "mappings": "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",
  "names": ["import_aws", "ServerlessError"]
}
