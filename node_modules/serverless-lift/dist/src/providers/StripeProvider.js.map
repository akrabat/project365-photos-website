{
  "version": 3,
  "sources": ["../../../src/providers/StripeProvider.ts"],
  "sourcesContent": ["import { existsSync, readFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { resolve } from \"path\";\nimport { parse as tomlParse } from \"toml\";\nimport { get, has } from \"lodash\";\nimport { Stripe } from \"stripe\";\nimport type { ConstructInterface, StaticConstructInterface } from \"@lift/constructs\";\nimport type { ProviderInterface } from \"@lift/providers\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport type { Serverless } from \"../types/serverless\";\nimport ServerlessError from \"../utils/error\";\n\nconst STRIPE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        profile: { type: \"string\" },\n    },\n    additionalProperties: false,\n} as const;\n\ntype StripeConfiguration = {\n    account_id: string;\n    device_name: string;\n    live_mode_api_key: string;\n    live_mode_publishable_key: string;\n    test_mode_api_key: string;\n    test_mode_publishable_key: string;\n};\n\ntype StripeConfigFile = { color: string } & Record<string, StripeConfiguration>;\ntype Configuration = FromSchema<typeof STRIPE_DEFINITION>;\n\nexport class StripeProvider implements ProviderInterface {\n    public static type = \"stripe\";\n    public static schema = STRIPE_DEFINITION;\n    private static readonly constructClasses: Record<string, StaticConstructInterface> = {};\n\n    static registerConstructs(...constructClasses: StaticConstructInterface[]): void {\n        for (const constructClass of constructClasses) {\n            if (constructClass.type in this.constructClasses) {\n                throw new ServerlessError(\n                    `The construct type '${constructClass.type}' was registered twice`,\n                    \"LIFT_CONSTRUCT_TYPE_CONFLICT\"\n                );\n            }\n            this.constructClasses[constructClass.type] = constructClass;\n        }\n    }\n\n    static getConstructClass(type: string): StaticConstructInterface | undefined {\n        return this.constructClasses[type];\n    }\n\n    static getAllConstructClasses(): StaticConstructInterface[] {\n        return Object.values(this.constructClasses);\n    }\n\n    static create(serverless: Serverless, id: string, { profile }: Configuration): StripeProvider {\n        return new this(serverless, id, profile);\n    }\n\n    private config: { apiKey: string; accountId?: string };\n    public sdk: Stripe;\n    constructor(private readonly serverless: Serverless, private readonly id: string, profile?: string) {\n        this.config = this.resolveConfiguration(profile);\n        this.sdk = new Stripe(this.config.apiKey, { apiVersion: \"2020-08-27\" });\n    }\n\n    createConstruct(type: string, id: string): ConstructInterface {\n        const Construct = StripeProvider.getConstructClass(type);\n        if (Construct === undefined) {\n            throw new ServerlessError(\n                `The construct '${id}' has an unknown type '${type}'\\n` +\n                    \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                \"LIFT_UNKNOWN_CONSTRUCT_TYPE\"\n            );\n        }\n        const configuration = get(this.serverless.configurationInput.constructs, id, {});\n\n        return Construct.create(this, id, configuration);\n    }\n\n    resolveConfiguration(profile?: string): { apiKey: string; accountId?: string } {\n        // Sourcing from env\n        if (profile === undefined && typeof process.env.STRIPE_API_KEY === \"string\") {\n            return { apiKey: process.env.STRIPE_API_KEY };\n        }\n\n        // Sourcing from TOML configuration file\n        const configsPath = process.env.XDG_CONFIG_HOME ?? resolve(homedir(), \".config\");\n        const stripeConfigFilePath = resolve(configsPath, \"stripe/config.toml\");\n        if (!existsSync(stripeConfigFilePath)) {\n            throw new ServerlessError(\n                \"Could not source any Stripe configuration. Have you set your STRIPE_API_KEY environment?\",\n                \"STRIPE_MISSING_CONFIGURATION\"\n            );\n        }\n\n        const stripeConfigurationFileContent = readFileSync(stripeConfigFilePath);\n        const stripeConfigurations = tomlParse(stripeConfigurationFileContent.toString()) as StripeConfigFile;\n        if (profile !== undefined) {\n            if (!has(stripeConfigurations, profile)) {\n                throw new ServerlessError(\n                    `There is no ${profile} profile in your stripe configuration. Found profiles are ${Object.keys(\n                        stripeConfigurations\n                    )\n                        .filter((stripeConfiguration) => stripeConfiguration !== \"color\")\n                        .join(\", \")}`,\n                    \"STRIPE_MISSING_PROFILE\"\n                );\n            }\n            const stripeConfig = stripeConfigurations[profile];\n\n            return {\n                apiKey: stripeConfig.test_mode_api_key,\n                accountId: stripeConfig.account_id,\n            };\n        }\n        // Fallback to default profile\n        if (!has(stripeConfigurations, \"default\")) {\n            throw new ServerlessError(\n                `There is no default profile in your stripe configuration. Please provide one of the found profiles: ${Object.keys(\n                    stripeConfigurations\n                )\n                    .filter((stripeConfiguration) => stripeConfiguration !== \"color\")\n                    .join(\", \")}`,\n                \"STRIPE_MISSING_DEFAULT_PROFILE\"\n            );\n        }\n        const defaultStripeConfig = stripeConfigurations.default;\n\n        return {\n            apiKey: defaultStripeConfig.test_mode_api_key,\n            accountId: defaultStripeConfig.account_id,\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["ServerlessError", "tomlParse"]
}
