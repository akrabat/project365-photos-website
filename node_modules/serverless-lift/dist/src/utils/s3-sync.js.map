{
  "version": 3,
  "sources": ["../../../src/utils/s3-sync.ts"],
  "sourcesContent": ["import type {\n    DeleteObjectsOutput,\n    DeleteObjectsRequest,\n    ListObjectsV2Output,\n    ListObjectsV2Request,\n    PutObjectOutput,\n    PutObjectRequest,\n    Object as S3Object,\n} from \"aws-sdk/clients/s3\";\nimport * as fs from \"fs\";\nimport * as util from \"util\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { lookup } from \"mime-types\";\nimport { chunk, flatten } from \"lodash\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport ServerlessError from \"./error\";\nimport { getUtils } from \"./logger\";\n\nconst readdir = util.promisify(fs.readdir);\nconst stat = util.promisify(fs.stat);\n\ntype S3Objects = Record<string, S3Object>;\n\n/**\n * Synchronize a local folder to a S3 bucket.\n *\n * @return True if some changes were uploaded.\n */\nexport async function s3Sync({\n    aws,\n    localPath,\n    targetPathPrefix,\n    bucketName,\n}: {\n    aws: AwsProvider;\n    localPath: string;\n    targetPathPrefix?: string;\n    bucketName: string;\n}): Promise<{ hasChanges: boolean; fileChangeCount: number }> {\n    let hasChanges = false;\n    let fileChangeCount = 0;\n    const filesToUpload: string[] = await listFilesRecursively(localPath);\n    const existingS3Objects = await s3ListAll(aws, bucketName, targetPathPrefix);\n\n    // Upload files by chunks\n    let skippedFiles = 0;\n    for (const batch of chunk(filesToUpload, 2)) {\n        await Promise.all(\n            batch.map(async (file) => {\n                const targetKey = targetPathPrefix !== undefined ? path.posix.join(targetPathPrefix, file) : file;\n                const fileContent = fs.readFileSync(path.posix.join(localPath, file));\n\n                // Check that the file isn't already uploaded\n                if (targetKey in existingS3Objects) {\n                    const existingObject = existingS3Objects[targetKey];\n                    const etag = computeS3ETag(fileContent);\n                    if (etag === existingObject.ETag) {\n                        skippedFiles++;\n\n                        return;\n                    }\n                }\n\n                getUtils().log.verbose(`Uploading ${file}`);\n                await s3Put(aws, bucketName, targetKey, fileContent);\n                hasChanges = true;\n                fileChangeCount++;\n            })\n        );\n    }\n    if (skippedFiles > 0) {\n        getUtils().log.verbose(`Skipped uploading ${skippedFiles} unchanged files`);\n    }\n\n    const targetKeys = filesToUpload.map((file) =>\n        targetPathPrefix !== undefined ? path.posix.join(targetPathPrefix, file) : file\n    );\n    const keysToDelete = findKeysToDelete(Object.keys(existingS3Objects), targetKeys);\n    if (keysToDelete.length > 0) {\n        keysToDelete.map((key) => {\n            getUtils().log.verbose(`Deleting ${key}`);\n            fileChangeCount++;\n        });\n        await s3Delete(aws, bucketName, keysToDelete);\n        hasChanges = true;\n    }\n\n    return { hasChanges, fileChangeCount };\n}\n\nasync function listFilesRecursively(directory: string): Promise<string[]> {\n    const items = await readdir(directory);\n\n    const files = await Promise.all(\n        items.map(async (fileName) => {\n            const fullPath = path.posix.join(directory, fileName);\n            const fileStat = await stat(fullPath);\n            if (fileStat.isFile()) {\n                return [fileName];\n            } else if (fileStat.isDirectory()) {\n                const subFiles = await listFilesRecursively(fullPath);\n\n                return subFiles.map((subFileName) => path.posix.join(fileName, subFileName));\n            }\n\n            return [];\n        })\n    );\n\n    return flatten(files);\n}\n\nasync function s3ListAll(aws: AwsProvider, bucketName: string, pathPrefix?: string): Promise<S3Objects> {\n    let result;\n    let continuationToken = undefined;\n    const objects: Record<string, S3Object> = {};\n    do {\n        result = await aws.request<ListObjectsV2Request, ListObjectsV2Output>(\"S3\", \"listObjectsV2\", {\n            Bucket: bucketName,\n            Prefix: pathPrefix,\n            MaxKeys: 1000,\n            ContinuationToken: continuationToken,\n        });\n        (result.Contents ?? []).forEach((object) => {\n            if (object.Key === undefined) {\n                return;\n            }\n            objects[object.Key] = object;\n        });\n        continuationToken = result.NextContinuationToken;\n    } while (result.IsTruncated === true);\n\n    return objects;\n}\n\nfunction findKeysToDelete(existing: string[], target: string[]): string[] {\n    // Returns every key that shouldn't exist anymore\n    return existing.filter((key) => target.indexOf(key) === -1);\n}\n\nexport async function s3Put(aws: AwsProvider, bucket: string, key: string, fileContent: Buffer): Promise<void> {\n    let contentType = lookup(key);\n    if (contentType === false) {\n        contentType = \"application/octet-stream\";\n    }\n    await aws.request<PutObjectRequest, PutObjectOutput>(\"S3\", \"putObject\", {\n        Bucket: bucket,\n        Key: key,\n        Body: fileContent,\n        ContentType: contentType,\n    });\n}\n\nasync function s3Delete(aws: AwsProvider, bucket: string, keys: string[]): Promise<void> {\n    const response = await aws.request<DeleteObjectsRequest, DeleteObjectsOutput>(\"S3\", \"deleteObjects\", {\n        Bucket: bucket,\n        Delete: {\n            Objects: keys.map((key) => {\n                return {\n                    Key: key,\n                };\n            }),\n        },\n    });\n\n    // S3 deleteObjects operation will fail silently\n    // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#deleteObjects-property\n    if (response.Errors !== undefined && response.Errors.length !== 0) {\n        response.Errors.forEach((error) => console.log(error));\n        throw new ServerlessError(\n            `Unable to delete some files in S3. The \"static-website\" and \"server-side-website\" construct require the s3:DeleteObject IAM permissions to synchronize files to S3, is it missing from your deployment policy?`,\n            \"LIFT_S3_DELETE_OBJECTS_FAILURE\"\n        );\n    }\n}\n\nexport function computeS3ETag(fileContent: Buffer): string {\n    return `\"${crypto.createHash(\"md5\").update(fileContent).digest(\"hex\")}\"`;\n}\n"],
  "mappings": "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",
  "names": ["ServerlessError"]
}
